<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhuWo&#39;s Den</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-29T04:10:43.975Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhuwo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rainy Day on Wu Kang Road</title>
    <link href="http://yoursite.com/2020/03/29/WuKangRoad/"/>
    <id>http://yoursite.com/2020/03/29/WuKangRoad/</id>
    <published>2020-03-29T03:43:07.000Z</published>
    <updated>2020-03-29T04:10:43.975Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Gallery" scheme="http://yoursite.com/categories/Gallery/"/>
    
    
      <category term="Photo" scheme="http://yoursite.com/tags/Photo/"/>
    
  </entry>
  
  <entry>
    <title>Shanghai SafariPark 2019</title>
    <link href="http://yoursite.com/2020/03/28/ShanghaiSafariPark2019/"/>
    <id>http://yoursite.com/2020/03/28/ShanghaiSafariPark2019/</id>
    <published>2020-03-28T07:10:12.000Z</published>
    <updated>2020-03-28T07:28:20.532Z</updated>
    
    <content type="html"><![CDATA[<p>Photo in Shanghai Safari Park in 2019</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Photo in Shanghai Safari Park in 2019&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Gallery" scheme="http://yoursite.com/categories/Gallery/"/>
    
    
      <category term="Photo" scheme="http://yoursite.com/tags/Photo/"/>
    
      <category term="SonyA2" scheme="http://yoursite.com/tags/SonyA2/"/>
    
  </entry>
  
  <entry>
    <title>ChinaJoy 2018</title>
    <link href="http://yoursite.com/2020/03/28/ChinaJoy2018/"/>
    <id>http://yoursite.com/2020/03/28/ChinaJoy2018/</id>
    <published>2020-03-28T05:41:45.000Z</published>
    <updated>2020-03-28T07:24:25.200Z</updated>
    
    <content type="html"><![CDATA[<p>  Photo at ChinaJoy in Shanghai 2018</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Photo at ChinaJoy in Shanghai 2018&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Gallery" scheme="http://yoursite.com/categories/Gallery/"/>
    
    
      <category term="Photo" scheme="http://yoursite.com/tags/Photo/"/>
    
  </entry>
  
  <entry>
    <title>悼念</title>
    <link href="http://yoursite.com/2019/09/20/Mourning/"/>
    <id>http://yoursite.com/2019/09/20/Mourning/</id>
    <published>2019-09-20T04:45:54.000Z</published>
    <updated>2020-03-28T01:50:22.996Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思绪"><a href="#思绪" class="headerlink" title="思绪"></a>思绪</h2><p>也许，只有古代有这样的环境，去抒发情感。</p><h2 id="亲人"><a href="#亲人" class="headerlink" title="亲人"></a>亲人</h2><p>“树欲静而风不止，子欲养而亲不再”。只有当亲人离自己而去了，才真正体会到这句话的深刻含义。人还在的时候，总是会烦，会有隔代人的意见相左。人不在的时候，却只留有无尽的遗憾。</p><p>亲情这份无法割舍的东西，也许是人存在和继续存在的缘由吧。人或许就是靠着这份代代相传，而得以寻找生存的理由。即便是历史，经历了几千年的时间，也要经过多方考证，才会有个大概的准确判断。所以，如果没有子孙后代，谁去思念他呢？人一去，就只剩白骨，时间久了，随风而走，成沙化尘。留在这世上的，唯有——亲人对其的思念。</p><p>时代在发展，信息如此庞大的今天，却远不及，在那个困苦的时候，亲人对自己的照顾，有着永远磨不去的记忆。以前，可能听多了，亲人唠唠叨叨，自己过去的生活种种，总是会厌烦。可真当离去，却希望，他有更多的故事留在我脑里。因为记得这些的也许只有我，谁知道以后的以后，会是怎么样？一代一代相传的意义，大概就是你有后人，还记得你，不求丰功伟业，只求延绵。</p><p>以前，总觉得自己想的万千世界，推理逻辑，严密无缺。到近来，看了朱光潜的《美学》，才稍微知道，艺术，也许源于孩童的天真想象，可它更需要的是表达，更需要别人也能意会出你所创造的世界。这很难，我迫切想要以优美的文字，记下此刻的心情感受。无奈，我只有我天马行空的想法，却无法流出，拙手拙文。</p><p>曾经，厌恶迷信，信奉自由意志。可是某个瞬间，忽然懂得，为什么前人要造出神明，造出来世。只不过，不希望亲人，真的就这么走了。即便如此真实，可内心希望它不真实。因此，造出另一个世界，让自己的内心，有一处地方，去安放惦念的亲人。祭拜亲人，形成传统，只不过不希望没人记得他们，只希望他在某种意义上，还一直在延绵。各种形式，烧纸钱也好，上香点蜡烛也好，只不过，单纯思念，难以维系。我依然反感迷信，可是，如果是思念亲人，我不会拒绝。</p><p>向前或向后，惋惜亲人的离去，才更懂得爱护身边的亲人。脾气是否不发便不发，意见相左，能纠则纠，不能则避。对待亲人，总得以赤子之心，却不失柔婉。做事得以目标和逻辑为重，做人确、却需拿捏尺寸、如履薄冰，人生得意需尽欢。在追求快乐，追求自己的人生的同时，是不是偶尔，也回头看看？时间长河前面，曾经牵着你的手，领着你走路的人。悲伤不过是思念，不要吝惜自己的眼泪。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思绪&quot;&gt;&lt;a href=&quot;#思绪&quot; class=&quot;headerlink&quot; title=&quot;思绪&quot;&gt;&lt;/a&gt;思绪&lt;/h2&gt;&lt;p&gt;也许，只有古代有这样的环境，去抒发情感。&lt;/p&gt;
&lt;h2 id=&quot;亲人&quot;&gt;&lt;a href=&quot;#亲人&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Ramble" scheme="http://yoursite.com/categories/Ramble/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2018年iOS面试总结</title>
    <link href="http://yoursite.com/2018/09/20/InterviewIn2018/"/>
    <id>http://yoursite.com/2018/09/20/InterviewIn2018/</id>
    <published>2018-09-20T04:45:54.000Z</published>
    <updated>2020-03-28T02:16:40.489Z</updated>
    
    <content type="html"><![CDATA[<p>从今年8月初开始找工作到现在，历时一个半月，终于进入了收尾的时候。这一个半月经历了很多，学习了很多，也成长了很多，所以做个总结。总结既是对这一个半月学到的东西，进行一个梳理，也是对未来的一个展望：公司需要的是什么样的人才，看中你的什么？自己需要培养什么技能，需要哪些习惯？本文按照三部分来做总结：第一部分，公司需要什么样的人才；第二部分，自己需要培养什么；第三部分，应聘iOS需要掌握些什么。第三部分，思路是按照第一部分和第二部分的总结，针对iOS需要的一个梳理。本文是从面试iOS的角度出发的，接下来的博文中的一些表达和思考可能会与计算机专业和iOS相关性比较大。</p><h1 id="公司需要什么样的人才"><a href="#公司需要什么样的人才" class="headerlink" title="公司需要什么样的人才"></a>公司需要什么样的人才</h1><h2 id="有哪些公司（目标）"><a href="#有哪些公司（目标）" class="headerlink" title="有哪些公司（目标）"></a>有哪些公司（目标）</h2><p>根据我面试的经历，我这边把公司分为四类，A类、B类、C类、D类，知名度和难度都是依次递减。A类是属于技术行业领先、知名度行业领先、公司业务发展行业领先，就我们行业论，BAT自是无话可说（这边不考虑巨头如Google、Facebook），还有已经被人熟知的京东，网易等，以及近几年崛起的如今日头条、滴滴、美团、饿了么等等。B类是，近两年发展很迅速，前景还不错的公司，如拼多多、爱奇艺。C类是已经稳定发展的创业公司，业务和各方面都还不错，资金都很充足。最后一类D类，可能是属于一些创业公司比较初期，或者是一些大公司旗下的子公司，也有可能是一些海外公司在国内拓展业务的子公司，这一类相对来说，人员不是很充足，团队也还需要壮大，一般比较冒险。</p><h2 id="公司是怎么样的要求"><a href="#公司是怎么样的要求" class="headerlink" title="公司是怎么样的要求"></a>公司是怎么样的要求</h2><p>这边，都是根据我自己面试经验的总结和推敲，不同类的公司，一般是怎么样的要求，如果有不对或不合理的地方，恳请指正。</p><p>由于有些要求是类似的，或者必须的，如果自上而下（A类-&gt;D类）介绍可能会有重复累赘，所以这边自下而上介绍。</p><p>首先是D类，这类公司一般会有一个明确的，需要的业务，比方说我面过的一家，是想自己包装一个浏览器，针对用户流量做一些事情。所以它可能会需要至少它业务相关方面的知识储备是有的，比方说对网络协议比较清楚，DNS比较了解。然后你去了，可能也不仅仅是做一个方向的事情，比方说你做APP客户端，如果会后台，也需要帮衬一下，可能相对会有一些杂事。然后，一些框架，前后端的架构，很有可能是用一些比较现成的。总的来说，要求不高，但还是可能会考你一些很基础的东西，简单的算法题，网络和操作系统的一些知识。</p><p>接下来是C类，这类公司业务比较成熟，技术团队规模不会太大，但一般都是相对有经验的人。它们的要求，除了你拥有基础以外，更多的可能是，实际经验，业务能力。我觉得，这方面短时间，比较难以补出来，所以还是有一定难度的。它们一般对基础不会问的太深入，但是会给你一个业务场景，需要你去实现这种业务场景。可能更需要的是，你平常对技术有研究，比方说热更新，平常业务可能很少用到，但是你如果去研究这种技术，看相关源码和实现，甚至动手写Demo，做实验，有这样的积累也是不错的。总之，要么你之前的公司很多业务，技术都是比较丰富的，要么自己研究的比较多。</p><p>然后再来看B类，这类公司发展和前景都不错，而且处于扩张期，粗放增长。它们对人才的需求量比较大，既有一定的基础，又有大量的业务。所以，对人才一般来说，基础会多看重些，经验可以相对少一些。它们的面试一般，会偏向计算机基础，但是会比较深入，算法要求会比较高。当然，对你所从事的方向的知识，考察的也会比较多。</p><p>最后是A类，这一类基本算是TOP了，既然是Top，要求也是Top了。不但对你的计算机基础，算法功底要求很高；对你从事方向的知识掌握也要比较全面；还有对你解决问题的能力要求都比较高。当然，经验充足，基础扎实，技术栈丰富。这些，都是作为一个技术人员，不断追求的目标。<strong>基础</strong>，是解决问题的能力和思路来源；<em>经验</em>，是解决问题的能力体现和积累；技术栈或知识储备，是未来发展方向和Idea的来源。</p><h1 id="自己需要培养什么"><a href="#自己需要培养什么" class="headerlink" title="自己需要培养什么"></a>自己需要培养什么</h1><p>总结，上文的公司要求，自己需要培养的能力和积累的东西，主要有: 基础，从事方向基础和原理，经验+及时更新自己的知识库，跟上最新的技术潮流。</p><p>首先是基础，计算机基础无非是：操作系统（编译链接），网络，算法和数据结构。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>主要考察最多的是：线程、进程。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>考察线程的东西最多</p><ol><li>线程和进程的区别和联系</li><li>多线程的实现方法</li><li>如何保证线程安全？加锁有哪几种方式/锁的实现方式有哪些？</li><li>死锁是什么？发生的条件？</li></ol><h3 id="编译连接"><a href="#编译连接" class="headerlink" title="编译连接"></a>编译连接</h3><ol><li>C程序是如何一步一步变为可执行文件的？</li><li>虚拟内存是什么，一个程序的内存分配是怎么样的？</li><li>编译器做的什么？链接期又做的什么？</li><li>静态库和动态库的区别？为什么要有动态库？</li><li>main函数是什么，为什么C程序的入口默认是main函数？</li></ol><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>基础的五层网络模型，TCP三次握手（四次挥手），上层的应用层（比较常见的有HTTP）</p><h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><ol><li>TCP和UDP的区别，哪些场景适合用UDP？</li><li>TCP如何进行拥塞避免？</li><li>滑动窗口是什么？具体是怎么样的？</li></ol><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>详细列举一下HTTP的关键知识： HTTP是一种无状态和无连接的协议（原因？）</p><ol><li>HTTP发送和接收的消息是如何包装的：头部+主体</li><li>HTTP头部有哪些组成成分（最主要的是哪些）？</li><li>HTTPS和HTTP的区别，HTTPS具体是怎么样实现请求的？</li></ol><h2 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h2><p>数据结构都是一些常用的，算法是需要不断练，也就是刷题的，这里推荐一些书籍。’</p><p>如果你对基础算法还不是很了解，《数据结构与算法分析》，有C语言版和Java版，简单易懂，看完就会对基本的数据结构比较了解，还有一些不太常用的数据结构也有介绍，希尔排序、不相交集、B树等。</p><p>如果想要进阶，肯定是《算法导论》，相对比较深奥，难以理解，可以挑自己感兴趣的，比方说，算法导论里的快排，简短精妙，短短几行代码就写完了，而且对复杂度的分析、改版都很透彻。</p><p>还有就是一些刷题的OJ，找工作本人比较推荐LeetCode。LeetCode的题分三个等级，Easy\Medium\Hard。如果你很久没写算法题，推荐先从Easy刷起，Easy和Medium的题一般考察的是对基本的算法和数据结构的掌握，所以一般基础相对薄弱的，就刷Easy和Medium就行了；Hard级别的偶尔想要挑战一下的时候，可以试一下。<br>然后刷题有几点建议：1. 推荐C++刷题：C++既需要你对算法有一定的思考（不那么方便），C++又有STL，有一些基本数据结构和算法可以拿来直接用，是锻炼算法的最佳（我认为）语言。 2. 不要用IDE，直接用LeetCode的编辑器：不借助IDE，有助于记住基本的API，忘记了就去cplusplus（C++）查询 ，培养手写代码的能力 3. 尽量自己写出来，实在写不出来，先看Hint；还不行，再看Discuss, 可以找Votes比较高的；最后写完了，或者写不出来，再看Solution。<br>LeetCode还有一个功能就是Tag, 按数据结构分: Tree、Stack、Graph等；所以还有一种思路，你可以先看完《数据结构与算法分析》的某一章，比方说“树”，然后专门刷Tree的题，巩固和提高对它的掌握。</p><h1 id="应聘iOS需要掌握些什么"><a href="#应聘iOS需要掌握些什么" class="headerlink" title="应聘iOS需要掌握些什么"></a>应聘iOS需要掌握些什么</h1><p>上面部分主要是作为计算机（IT）面试都需要掌握的知识，只是不同方向，不同公司可能深浅不一，我也只是从我的面试经历总结，可能会有偏颇和遗漏。接下来的部分，是我作为一个iOS开发，面试iOS岗位的一些知识的总结。</p><p>我按三个部分来讲，原理，架构和其他，其他部分比较杂，但是是一些做iOS都会用到的知识和技能。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>Objective-C Runtime</li><li>iOS Runloop</li><li>事件响应链</li><li>内存管理：MRC，ARC，autorelease</li><li>Block</li><li>GCD</li><li>JSCore(Exception)</li></ol><h3 id="Objective-C-Runtime"><a href="#Objective-C-Runtime" class="headerlink" title="Objective-C Runtime"></a>Objective-C Runtime</h3><p>最基本的，要对Runtime有一定了解，OC的Runtime是什么？消息是如何转发的？</p><p>会问到的一些问题：</p><blockquote><ol><li>你怎么理解OC的动态性?</li><li>系统有哪些利用Runtime的应用？（KVO， Category）</li><li>KVO是怎么实现的？</li><li>Category可以添加方法吗？可以添加属性吗？为什么?</li><li>Runtime有哪些应用？</li><li>NSProxy了解吗？</li><li>RunTime中涉及到的结构体是怎么样的？</li></ol></blockquote><h3 id="iOS-Runloop"><a href="#iOS-Runloop" class="headerlink" title="iOS Runloop"></a>iOS Runloop</h3><p>基本的，要对Runloop了解？Runloop是什么？它的结构是怎么样的？Runloop的内部逻辑（流程）？</p><p>会问到的一些问题：</p><blockquote><ol><li>如何把一个任务放到下一个Runloop执行？</li><li>为什么Tableview下拉刷新的时候，timer会失效？解决方法？</li><li>Timer放在主线程和子线程一样吗？如果不一样，有什么区别？</li><li>为什么Timer必须要invalidate?</li></ol></blockquote><h3 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h3><p>基本的，描述iOS事件传递的整个过程？</p><p>会问到的一些问题：</p><blockquote><ol><li>有这样一个应用场景。一个应用的Tabbar上，有几个按钮，但是按钮的一部分在Tabbar范围外，如何做到点击按钮Tabbar范围外的地方，也能响应？</li><li>给一个Tableview的Cell添加手势，事件响应链会有怎么样的变化？会先响应手势呢，还是Cell会先响应？</li><li>UIControl在事件响应链中的作用，以及它的优先级？</li></ol></blockquote><h3 id="内存管理：MRC，ARC，autorelease"><a href="#内存管理：MRC，ARC，autorelease" class="headerlink" title="内存管理：MRC，ARC，autorelease"></a>内存管理：MRC，ARC，autorelease</h3><p>内存管理，基本的，iOS的内存管理是怎么样的?然后比较多问的，是问OC属性相关引发的问题</p><p>会问到的一些问题：</p><blockquote><ol><li>OC的属性中，哪些和内存相关？</li><li>哪些类型需要用copy属性？</li><li>assign一般修饰什么？它可以修饰对象吗？</li><li>strong和weak的区别？weak是如何实现的？</li><li>如何避免循环引用？</li><li>weak和unsafe_unretained有什么区别？什么情况下会用到unsafe_unretained？</li><li>autoreleasepool了解吗？什么情况下会需要用到？</li></ol></blockquote><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>基本的，Block是什么,为什么要有Block？Block是如何实现的？它放在内存的哪个区域？</p><p>会问到的一些问题：</p><blockquote><ol><li>什么情况下需要用<strong>block，</strong>block是如何实现的，对应的对象是放在堆上还是栈上？</li><li>block会造成循环引用吗？什么情况下会造成？有哪些方法解决循环引用？</li><li>block为何一般需要copy属性？</li></ol></blockquote><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD和多线程相关，所以会问一些线程相关的东西引入。比方说iOS有哪几种多线程的方式？OperationQueue和GCD的区别？GCD的优势和劣势？</p><p>会问到的一些问题：</p><blockquote><ol><li>如何理解dispatch_async和dispatch_sync？</li><li>什么情况下会用到dispatch_group？</li><li>如何理解串行队列和并行队列？它是怎么实现的？</li><li>main_queue和global_queue是什么？分别是串行的，还是并行的？</li><li>如果一个通知在global_queue中添加observer，然后又再main_queue中发送通知，那么这个通知的任务最后在主线程，还是子线程执行？</li><li>dispatch_once是如何保证原子性的？</li><li>每创建一个新的队列就会产生一个新的线程吗？线程数量是有限的吗？如果要你定一个线程池的大小，你会选择多大？理由？</li></ol></blockquote><h3 id="JSCore"><a href="#JSCore" class="headerlink" title="JSCore"></a>JSCore</h3><p>JSCore相比于前面的原理不是那么重要，但是很多与JS打交道的东西都和它有关，比方说热更新的一些方案，JS_bridge的实现方案，RN、Weekx，都是基于它的；还有，最基本的，iOS的浏览器内核，主要是WebKit，主要的组成就是JSCore。主要是要搞清楚Webkit的组成，JSCore在其中扮演的角色，它是干什么的?</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>iOS主要架构有MVC、MVP、MVVM，还有VIPER。可以找一些相关的博文深入理解和分析一下。关于MVVM，推荐Limboy的博客，介绍MVVM和使用RAC实现MVVM讲得很详细。</p><p>可能会问的问题：</p><ol><li>你怎么理解MVC和MVVM？</li><li>我们知道RxSwift可以很容易实现数据的绑定，那么你知道它的原理吗？它是基于RAC的，对RAC的实现了解吗？</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>组件化</li><li>热更新</li><li>持续化集成（CI）</li><li>设计模式</li><li>第三方库</li></ol><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化是17年比较火的一个概念，最早是由蘑菇街的Limboy提出组件化的方案和思路，然后Casa针对Limboy的方案提出一些改进和建议的思路，并给出了简单的Demo, 然后Bang在前三篇文章基础之上做了清晰的总结；然后，就掀起了一片讨论和热潮。我这边就不详细讨论了，研究得也还不是很透彻，所以，就简单贴几个链接。如果作者觉得侵权了，可以随时联系我删除。</p><ol><li><a href="http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="noopener">蘑菇街组件化之路</a></li><li><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></li><li><a href="http://limboy.me/tech/2016/03/14/mgj-components-continued.html" target="_blank" rel="noopener">蘑菇街 App 的组件化之路·续</a></li><li><a href="http://blog.cnbang.net/tech/3080/" target="_blank" rel="noopener">iOS 组件化方案探索</a></li></ol><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>热更新，是利用Objective-C的动态性，加上JSCore，实现对已有代码的更新和修复。所以，主要利用了OC的runtime和JSCore实现。使用最广泛第三方库实现是JSPatch，作者有对它实现整个库的过程和原理，有详细的博文说明。通过阅读它的源码和分析，基本上可以对热更新这一技术有一个比较全面的了解。</p><h3 id="持续化集成（continue-integrate）"><a href="#持续化集成（continue-integrate）" class="headerlink" title="持续化集成（continue integrate）"></a>持续化集成（continue integrate）</h3><p>持续化集成，是一个能够极大提高生产效率的一个思路。由于，很多公司的项目庞大，编译一次可能耗时几小时，甚至几天的时间。所以，能够在合适的时间自动编译，自动部署可以大幅度的减少一些重复和不必要的工作。目前iOS用的比较多的，有Jenkins和Fastlane。本人研究还不够深入，所以暂时不详细阐述。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式，其实面是向对象开发过程中，为了提高代码的复用性、可读性和可靠性，一套被反复使用的、许多程序猿验证使用、并梳理分类过的总结。苹果在iOS系统上，自己本身就应用了很多常见的设计模式。关于设计模式，网上介绍的有一大堆，但真实能否用起来，理解可能光看这些还不够。</p><p>我这边推荐一本书，《设计模式:可复用面向对象软件的基础(英文版)》，它囊括了基本所有常见的设计模式，而且每个设计模式，都是按目的、动机、结构、应用场景、优缺点和实际例子，还有常见的具体应用来讲述的。稍稍有点比较晦涩难懂，是因为它需要一定的抽象能力，但是你一旦理解了，对这个设计模式掌握得也就比较透彻了。书中的例子都是用C++写的，想必程序员对C++都应该不会陌生。</p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>第三方库，平常开发过程中经常会用到第三方库，由于它们的各种优点：易用、安全、高效等。其实，一些优秀的第三方库有很多值得我们学习和借鉴的地方，平常如果经常阅读它们的源代码可以学到很多东西。它们实现某个功能的思路，和解决问题的方法，还有一些良好的代码习惯，甚至是应对一些小点的一些Trick。有些第三方库的作者，不仅开源它们的代码，还自己写博客分析它们的库和写库的经历。作为一个程序员，学习和模仿是必备技能，而阅读第三方库，是一个相对比较高效和受益颇多的方法。</p><p>扯完淡，讲点实在的，简单介绍一下iOS常用的第三方库。</p><p>AFNetwork，客户端与后台、或固件的交互都是基于网络请求的，苹果系统自带就有网络请求库，URLConnection、URLSession，那么既然系统自带，为什么不用系统的呢？通过阅读AFNetwork，你能知道一个HTTP请求构成，需要哪些步骤，消息如何封装，还能看到它使如何处理和安排上层的多个请求的，还能够大致了解和掌握HTTPS的一个过程。</p><p>YYCache，YYCache的作者，自己就有分享它写这个库的过程和考量，以及自己解决问题的思路和最后的方案。通过学习YYCache，你可以对缓存设计有一定的思路和了解。</p><p>JSPatch，热更新的一个广泛备用的开源库。这个库的作者，也详细介绍了它写这个库的初衷，想法，初始设计和存在问题、解决问题的过程。通过他的介绍，你会对这种热更新有个全面的认识，也会对JS和客户端交互的一些方法有些了解，还有更加体会到OC Runtime的好处和精髓。</p><p>然后，还有很多很多，优秀的库值得我们学习。。。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>最后，写一些这一趟面试下来，觉得作为一个程序员需要培养注意的东西和养成的一些习惯，主要是用来提醒自己，和同样需要在这个方向不断前行的小伙伴。</p><blockquote><ol><li>多逛社区，阅读博客，跟上最新的技术潮流，学习新的技术</li><li>多看开源库，学习优秀代码</li><li>多写代码实践和验证一些理论，积攒经验和掌握理论</li><li>多做题，锻炼自己解决问题和巩固算法数据结构</li><li>多写博客，总结、分享自己的工作和研究</li><li>多和其他技术人员交流，分享自己的学习和知识（多写PPT演讲）</li></ol></blockquote><p> 最后的最后，感谢你看到这儿，有什么问题，欢迎指出和纠正；有什么建议，欢迎提出和讨论。<br> 我的Email地址: <a href="mailto:huanjianjiang@gmail.com" target="_blank" rel="noopener">huanjianjiang@gmail.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从今年8月初开始找工作到现在，历时一个半月，终于进入了收尾的时候。这一个半月经历了很多，学习了很多，也成长了很多，所以做个总结。总结既是对这一个半月学到的东西，进行一个梳理，也是对未来的一个展望：公司需要的是什么样的人才，看中你的什么？自己需要培养什么技能，需要哪些习惯？本
      
    
    </summary>
    
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift下的状态设计模式</title>
    <link href="http://yoursite.com/2018/06/11/SwiftStatePattern/"/>
    <id>http://yoursite.com/2018/06/11/SwiftStatePattern/</id>
    <published>2018-06-11T11:18:01.000Z</published>
    <updated>2020-03-28T02:16:21.550Z</updated>
    
    <content type="html"><![CDATA[<p>  如果你的对象拥有许多状态，那么你或许可以考虑一下使用<strong>状态</strong>模式。在这篇博文中，我们将覆盖到一些关于<em>状态</em>模式的一些理论，然后会以一个列子说明如何实现它。希望，阅读完这篇文章以后，你会比较熟悉<em>状态</em>设计模式。</p><h2 id="状态设计模式"><a href="#状态设计模式" class="headerlink" title="状态设计模式"></a>状态设计模式</h2><p>当你在做项目的时候，很有可能碰到一个类有很多内部状态。举个栗子，比方说你有一个从服务器下载大图的类。这个类就有可能处于好几种不同的状态：请求中、下载中、处理中、保存中、、、等等。</p><p>在我们的例子中我们将使用一辆汽车。我们的汽车可以处于停止的状态，它也能够处于移动中、或者自动停车状态。这辆汽车将会有它的功能，比方说刹车和停车。根据汽车所处的状态，使用不同的功能将会有不一样的效果。如果对停止状态的汽车发送刹车指令，将没有任何效果；而对一个正在自动停车状态的车发送刹车指令，将会使汽车取消它的停车操作。</p><p>这辆汽车能够内部控制它自己的状态，我们不需要知道，或者无须关心它到底处于什么状态。从本文前面的说明，你知道，调用同一个功能，但对象处于不同的状态的时候，会产生不一样的结果。这也给我们带来了<strong>状态</strong>设计模式的定义如下：</p><blockquote><p><em>状态设计模式允许一个对象在它的内部状态改变的时候，改变它自己的行为。这个对象看起来好像能够改变它的类型</em>。</p></blockquote><p>到这里为止，已经足够覆盖状态设计模式的理论。接下来，让我们先看一下几幅图表。</p><h2 id="汽车状态"><a href="#汽车状态" class="headerlink" title="汽车状态"></a>汽车状态</h2><p>我们将要在一个汽车类上实现“状态设计模式”。我们的汽车将会有三个不一样的状态，如图1-1</p><img src="/2018/06/11/SwiftStatePattern/states.jpg" title="图1-1"><p>汽车能够改变状态，但是有几个规则需要遵守。例如，你不能直接从移动状态变为停车状态，你需要先转换到停止状态。</p><p>如果你正在思考如何将汽车的这些行为实现到你的汽车类当中，你也许会想到用一个枚举来存储汽车类的状态信息。想象一下你的函数将会是怎么样的，你的代码中会出现很多switch cases。你的汽车类将会变的相当庞大，并且会难以维护。</p><p>我们将要做的是，将每个’cases’或者状态独立成它自己的一个类。汽车类将会有一个对当前状态的引用。这将允许它们控制汽车的当前状态。下面图1-2，是一个关于我们类的层次的简要图。</p><img src="/2018/06/11/SwiftStatePattern/classdiagram.jpg" title="图1-2"><p>让我们具体来研究一下它，并且开始着手写代码。。。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们将会尽量保持代码简单，便于理解。我们的汽车类将会有三个函数，一个用来存储速度的变量和一些创建状态的工厂方法；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">VehicleProtocol</span>: <span class="title">class</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// MARK: - Vehicle State</span></span><br><span class="line">    <span class="keyword">var</span> speed: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setState</span><span class="params">(<span class="number">_</span> state: VehicleState)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - Vehicle Controls</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: - State Getters</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getStoppedState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getMovingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getParkingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个使用汽车的类，一般情况下只能通过调用‘vehicle controls’中的函数的方式，与汽车交互。 其他的函数/变量只能被状态类使用。</p><p>调用任何控制函数只是简单的将汽车转变为目标状态，而当前的汽车状态会具体处理需要做的事情；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    state?.accelerate()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    state?.brake()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</span><br><span class="line">    state?.park()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的汽车使用工厂方法来创建汽车状态；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - State Getters</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStoppedState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">StoppedState</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMovingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">MovingState</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getParkingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">ParkingState</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你将在这里开始看到模式的合并，也就是将所有状态串起来（不知道这么说合不合适）。每个状态类有一个指回汽车的指针，而且它能够创建新的状态。到现在为止，就差一口气了，那就是实现这些状态类。</p><h2 id="状态类（State-Classes）"><a href="#状态类（State-Classes）" class="headerlink" title="状态类（State Classes）"></a>状态类（State Classes）</h2><p>我们将针对我们的汽车状态使用一个协议（Protocol）:<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">VehicleState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  每个状态函数都会有一个指回汽车类的引用。并且每个状态类将会实现汽车的控制函数。我们将会在接下来的瞬间看到，每个不一样的状态类，调用汽车的（可能是相同的）控制函数，将会有不同的意义和作用。</p><h3 id="停止状态（Stopped）"><a href="#停止状态（Stopped）" class="headerlink" title="停止状态（Stopped）"></a>停止状态（Stopped）</h3><p>  让我们先看一下最简单的状态，停止状态；</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StoppedState</span>: <span class="title">VehicleState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle: <span class="type">VehicleProtocol?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle = vehicle</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle?.speed += <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> movingState = <span class="keyword">self</span>.vehicle?.getMovingState() &#123;</span><br><span class="line">            <span class="keyword">self</span>.vehicle?.setState(movingState)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Can't brake... Vehicle is already stopped!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> parkingState = <span class="keyword">self</span>.vehicle?.getParkingState() &#123;</span><br><span class="line">            <span class="keyword">self</span>.vehicle?.setState(parkingState)</span><br><span class="line">            parkingState.park()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  当汽车在停止状态的时候，调用‘accelerate’方法，将会提高汽车的速度5（kph，具体多少并不重要）。它同时也会使得汽车进入新的状态，也就是移动状态。调用‘brake’函数不会有任何作用，因为汽车已经本来就是停止状态。而调用‘park’函数将会使得汽车进入自动停车的过程。</p><h3 id="停车状态（Parking）"><a href="#停车状态（Parking）" class="headerlink" title="停车状态（Parking）"></a>停车状态（Parking）</h3><p>停车状态稍微有点意思；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkingState</span>: <span class="title">VehicleState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle: <span class="type">VehicleProtocol?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> parking: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle = vehicle</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Vehicle is automatically parking, you can't accelerate!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Automatic parking has been aborted"</span>)</span><br><span class="line">        stopParking()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.parking == <span class="literal">false</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Vehicle is already parking"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Vehicle is now parking"</span>)</span><br><span class="line">        <span class="keyword">self</span>.parking = <span class="literal">true</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.stopParking()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">stopParking</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Vehicle has stopped parking"</span>)</span><br><span class="line">        <span class="keyword">self</span>.parking = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> stoppedState = <span class="keyword">self</span>.vehicle?.getStoppedState() &#123;</span><br><span class="line">            <span class="keyword">self</span>.vehicle?.setState(stoppedState)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们可以看到‘brake’函数将会停止汽车的停车过程。有趣的是，调用‘park’函数将会引发一系列的事件。你可以对这个方法的内容提出异议，也就是针对‘停止状态’可以有更好的方法，但是为了简单起见，让我们暂时保持这样（Take it easy!）。</p><h3 id="移动状态（Moving）"><a href="#移动状态（Moving）" class="headerlink" title="移动状态（Moving）"></a>移动状态（Moving）</h3><p>移动状态也同样非常简单；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingState</span>: <span class="title">VehicleState</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle: <span class="type">VehicleProtocol?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle = vehicle</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle?.speed += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.vehicle?.speed -= <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.vehicle?.speed == <span class="number">0</span>, <span class="keyword">let</span> stoppedState = <span class="keyword">self</span>.vehicle?.getStoppedState() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Vehicle braked to a stop"</span>)</span><br><span class="line">            <span class="keyword">self</span>.vehicle?.setState(stoppedState)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Can't park the vehicle while it's moving. You need to stop first"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在这里看到，我们在‘brake’函数中有一小段不一样的逻辑，就是，如果速度掉到0，将会使得汽车进入到停止状态。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>让我们迫不及待的测试一下，我们的汽车：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testVehicle</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> vehicle = <span class="type">Vehicle</span>()</span><br><span class="line">    vehicle.brake()</span><br><span class="line">    vehicle.accelerate()</span><br><span class="line">    vehicle.accelerate()</span><br><span class="line">    vehicle.brake()</span><br><span class="line">    vehicle.park() <span class="comment">// prints: Can't park the vehicle while it's moving. You need to stop first</span></span><br><span class="line">    vehicle.brake()</span><br><span class="line">    vehicle.park()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，我们第一次调用‘park’方法将会打印出一条消息，意思是“汽车必须是停止状态，才能够停车”，当我们刹车以后，第二次调用，才会产生预期的结果。这个简单的测试表现出了我们的汽车是如何在运行中改变状态的。调用同一个类实例的同一个方法会产生不一样的结果。哈哈，这就是<strong>状态</strong>模式的精髓。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你看到一个类有很多的<code>switch-case</code>语句的时候，就表示你可以考虑一下使用状态模式。我们可以很简单的使用枚举来表示汽车的当前状态。但是函数会变得很庞大，业务逻辑将会出现在case代码快里边，代码很有可能会变得杂乱而难以维护。这个简单的设计模式也许能够轻松的解决这个问题。当然，随着项目的发展，你会有很多很多的类，类的层次会很复杂。但是别担心，用了状态模式，你的代码照样能够易于理解，可扩展。不信，你可以试一试！毕竟没有什么损失。</p><p>我希望今天你能在这学到一些新东西，新知识。<br>和往常一样，希望有一个开心的日子😊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  如果你的对象拥有许多状态，那么你或许可以考虑一下使用&lt;strong&gt;状态&lt;/strong&gt;模式。在这篇博文中，我们将覆盖到一些关于&lt;em&gt;状态&lt;/em&gt;模式的一些理论，然后会以一个列子说明如何实现它。希望，阅读完这篇文章以后，你会比较熟悉&lt;em&gt;状态&lt;/em&gt;设计模式。
      
    
    </summary>
    
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>同步和异步</title>
    <link href="http://yoursite.com/2018/01/25/SyncAndAsync/"/>
    <id>http://yoursite.com/2018/01/25/SyncAndAsync/</id>
    <published>2018-01-25T03:49:01.000Z</published>
    <updated>2020-03-28T01:34:00.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>假设你有两个任务，任务A和B：A先执行，B后执行。<br>同步意味着，当你要执行任务B的时候，你必须要等到任务A执行完成，才能执行任务B, 也就是顺序执行。异步意味着，你执行A一段时间以后，但是还没有结束，你可以先执行任务B。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>技术上讲，同步/异步的概念跟线程其实不相关。尽管，很少有异步的任务在单线程上跑，但是还是有可能的，两个或更多任务在同一线程上异步执行。同步/异步的概念仅仅与，是否有第二个或者接下来的任务能在其他（第一个）任务完成前开始执行，或者它是不是必须等待。其他不管什么线程、进程、CPU，或者实际上的什么硬件都没有关系。</p><p>同步/异步的不准确解释：</p><blockquote><ol><li>同步意味着两个或者多个任务在同一个上下文（线程）运行，所以一个任务或阻塞另一个任务</li><li>同步意味着两个或者多个任务顺序的发生</li><li>异步意味着两个或者多个任务在不同的上下文（线程）运行，所以它们可以并发执行而不会互相阻塞</li><li>异步意味着两个或者多个任务异步地发生</li><li>等等。。。</li></ol></blockquote><h3 id="异步代码可能运行或者可能不运行在同一线程中"><a href="#异步代码可能运行或者可能不运行在同一线程中" class="headerlink" title="异步代码可能运行或者可能不运行在同一线程中"></a>异步代码可能运行或者可能不运行在同一线程中</h3><h3 id="同步操作能够顺序地执行，也能够同步执行"><a href="#同步操作能够顺序地执行，也能够同步执行" class="headerlink" title="同步操作能够顺序地执行，也能够同步执行"></a>同步操作能够顺序地执行，也能够同步执行</h3><h2 id="异步可能出现情况"><a href="#异步可能出现情况" class="headerlink" title="异步可能出现情况"></a>异步可能出现情况</h2><ol><li>磁盘I/O</li><li>网络请求</li><li>DMA（直接内存存取）</li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol><li><a href="https://codewala.net/2015/07/29/concurrency-vs-multi-threading-vs-asynchronous-programming-explained/" target="_blank" rel="noopener">Concurrency vs Multi-threading vs Asynchronous Programming : Explained</a></li><li><a href="https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean" target="_blank" rel="noopener">Stackoverflow: Asynchronous vs synchronous execution</a></li><li><a href="https://www.javatpoint.com/understanding-synchronous-vs-asynchronous" target="_blank" rel="noopener">Synchronous vs Asynchronous Under Web-Application</a></li><li><a href="https://www.codeproject.com/Articles/127660/What-are-actually-synchronous-asynchronous-operati" target="_blank" rel="noopener">Code Project:What are Actually Synchronous/Asynchronous Operations</a></li><li><a href="https://www.safaribooksonline.com/library/view/linux-system-programming/0596009585/ch04s05.html" target="_blank" rel="noopener">O’REILLY Linux System Programming: Synchronized, Synchronous, and Asynchronous Operations</a></li><li>[Programmr:The difference between asynchronous and non-blocking] (<a href="http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking" target="_blank" rel="noopener">http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking</a>)</li><li><a href="https://www.google.co.id/search?q=asynchronous+programming&amp;safe=active&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjwiaPK6c7VAhVFpI8KHQ7-CWQQ_AUICygC&amp;biw=1680&amp;bih=858#imgrc=TXJCeZEAG_CE-M" target="_blank" rel="noopener">https://www.google.co.id/search?q=asynchronous+programming&amp;safe=active&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjwiaPK6c7VAhVFpI8KHQ7-CWQQ_AUICygC&amp;biw=1680&amp;bih=858#imgrc=TXJCeZEAG_CE-M</a>:</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h1&gt;&lt;p&gt;假设你有两个任务，任务A和B：A先执行，B后执行。&lt;br&gt;同步意味着，当你要执行任务B的时候，你必须要等到任务A执行
      
    
    </summary>
    
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Swift 属性</title>
    <link href="http://yoursite.com/2017/12/07/SwiftProperties/"/>
    <id>http://yoursite.com/2017/12/07/SwiftProperties/</id>
    <published>2017-12-07T02:58:01.000Z</published>
    <updated>2020-03-28T02:16:33.781Z</updated>
    
    <content type="html"><![CDATA[<p><strong>属性</strong>关联特定类、结构体或枚举的值。Swift主要有存储属性和计算属性。存储属性存储实例的常量或者变量值，然而计算属性主要是计算值（而不是存储值），相当于是附加属性，可以用已有的存储属性计算得到。</p><p>计算和存储属性同样一般是关联特定类型的实例。然而，属性同样能够和类型本身关联。这样的属性叫做类型属性。</p><p>此外，你还能够定义属性观察器来监视属性值的变化，利用它，你可以写一些响应的操作。属性观察器既能够自己定义，也能够从父类当中继承得到。</p><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>存储属性，最简单的形式，就是存储在一个特定的类或机构体的实例中的，一个常量或变量。存储属性既可以是变量（由关键字<code>var</code>定义），也可以是常量（由关键字<code>let</code>定义）。</p><p>下面的例子，定义了一个结构FixedLengthRange，描述了一个整型数据的范围，其中的范围长度创建以后就不能改变。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// the range represents integer values 0, 1, and 2</span></span><br><span class="line">rangeOfThreeItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// the range now represents integer values 6, 7, and 8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常量结构体实例的存储属性"><a href="#常量结构体实例的存储属性" class="headerlink" title="常量结构体实例的存储属性"></a>常量结构体实例的存储属性</h3><p>假如你创建了一个结构体实例，并将它赋给一个常量，那么你就不能改变这个实例的属性，包括变量属性，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> rangeOfFourItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// this range represents integer values 0, 1, 2, and 3</span></span><br><span class="line">rangeOfFourItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// this will report an error, even though firstValue is a variable property</span></span><br></pre></td></tr></table></figure><p>因为<code>rangeOfFourItems</code>被声明为一个常量，所以不可能改变它的<code>firstValue</code>属性，尽管它是一个变量属性。</p><p>这个行为是因为结构体属于<em>值类型</em>。值类型的实例如果标记为常量，那么它的所有属性都是常量。</p><p>这中情况对类并不适用，类是<em>引用类型</em>。假如你将一个引用类型的实例赋给一个常量，你仍然可以改变实例的变量属性。</p><h3 id="懒（加载）存储属性"><a href="#懒（加载）存储属性" class="headerlink" title="懒（加载）存储属性"></a>懒（加载）存储属性</h3><p>懒属性就是一种属性，直到它第一次被使用，它的值才会被计算。</p><blockquote><p>注意点<br><strong>懒属性必须声明为一个变量，因为它的初始值不会被用到，在实例初始化完成后。而常量属性必须在初始化完成以后有值，因此它不能被声明为懒属性</strong></p></blockquote><p>懒属性在以下情况下非常有用：它的值依赖于外在因素，也就是实例初始化完以后，这些外在因素还不知道的情况。还有就是，属性的值计算非常复杂或者计算代价非常高。只有使用它的时候去计算最好。</p><p>下面例子，利用懒存储属性，避免一个复杂类的不必要初始化。这个例子定义两个类<code>DataImporter</code>和<code>DataManager</code>:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     DataImporter is a class to import data from an external file.</span></span><br><span class="line"><span class="comment">     The class is assumed to take a nontrivial amount of time to initialize.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> filename = <span class="string">"data.txt"</span></span><br><span class="line">    <span class="comment">// the DataImporter class would provide data importing functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// the DataManager class would provide data management functionality here</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">"Some data"</span>)</span><br><span class="line">manager.data.append(<span class="string">"Some more data"</span>)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property has not yet been created</span></span><br></pre></td></tr></table></figure><p><code>DataManager</code>类用来管理属性<code>data</code>, 一个<code>String</code>数组。</p><p><code>DataManager</code>的部分功能是从文件当中获取<code>data</code>。然后这个功能是由类<code>DataImporter</code>提供的，需要花费相当多的时间进行初始化。这可能是因为<code>DataImporter</code>实例需要打开文件，将文件内容读入到内存等等。</p><p>但是使用了懒属性，使用<code>lazy</code>标记，<code>importer</code>属性对应的<code>DataImporter</code>实例，只有当<code>importer</code>属性第一次被使用的时候才会被创建，比方说它的文件名被访问的时候；<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.filename)</span><br><span class="line"><span class="comment">// the DataImporter instance for the importer property has now been created</span></span><br><span class="line"><span class="comment">// Prints "data.txt"</span></span><br></pre></td></tr></table></figure></p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>除了存储属性，类，结构体和枚举也能够定义<em>计算属性</em>，它实际上不存储一个值。相反，它们提供一个获取和可选的设置，用来直接检索或设置属性和值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">                  size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter = square.center</span><br><span class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (\(square.origin.x), \(square.origin.y))"</span>)</span><br><span class="line"><span class="comment">// Prints "square.origin is now at (10.0, 10.0)"</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子定义来地理形状的三个结构：</p><ul><li><code>Point</code>封装了一个点的x-和y-坐标</li><li><code>Size</code>封装了长度和宽度</li><li><code>Rect</code>定义了一个长方形通过一个原点的点和尺寸</li></ul><p><code>Rect</code>结构同样提供了一个计算属性<code>center</code>。这个属性可以依赖orgin和size算出来，设置它，可以通过size，改变origin。也就是计算属性，主要是提供一些不是最原始的属性，但是又可以方便用户使用和设置的一种属性。</p><h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>计算属性只有获取（getter）就叫做只读计算属性。只读计算属性经常返回一个值，所以可用<strong>点</strong>的语法获取。</p><p>同样，可以用简写的形式，去掉<code>get</code>关键字和它的大括号：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height * depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)"</span>)</span><br><span class="line"><span class="comment">// Prints "the volume of fourByFiveByTwo is 40.0"</span></span><br></pre></td></tr></table></figure><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器观察并对属性值的变化作出响应。属性观察器，在每一次属性值设置的时候都会被调用，即使新的属性值和现在的值一样。</p><p>你可以给任何存储属性添加属性观察器，除了懒加载存储属性。你也可以给任何继承的属性添加属性观察器，通过在子类中重写属性。</p><p>你可以针对一个属性，定义单个或者同时定义两个观察器。</p><ul><li><code>willSet</code>在值被存储前被调用</li><li><code>disSet</code>在新值存储后立即被调用</li></ul><p>如果你实现一个<code>willSet</code>观察器，它会被传递新的属性值作为常量参数，并且你可以对这个人参数指定一个名字。如果你不指定名字，这个参数的默认名字为<code>newValue</code>。</p><p>类似的，如果你实现<code>disSet</code>观察器，它会被传递一个常量参数，包含的是先前的值。你同样可以为这个参数命名，或者使用默认值<code>oldValue</code>。</p><p>接下来，是一个<code>willSet</code>和<code>disSet</code>的例子。这个例子，是一个<code>StepCounter</code>的类，用来记步，它用一个变量<code>totalSteps</code>来记录当前的步数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to set totalSteps to \(newTotalSteps)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Added \(totalSteps - oldValue) steps"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps = <span class="number">200</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 200</span></span><br><span class="line"><span class="comment">// Added 200 steps</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">360</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 360</span></span><br><span class="line"><span class="comment">// Added 160 steps</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">896</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 896</span></span><br><span class="line"><span class="comment">// Added 536 steps</span></span><br></pre></td></tr></table></figure><p>这个类用一个变量<code>totalSteps</code>来记录当前的步数。无论什么时候，只要属性被赋予新值，其中的<code>willSet</code>和<code>disSet</code>观察器都会被调用。<code>willSet</code>中，每次都会输出新的步数。而在<code>didSet</code>中，当新的步数超过旧的步数的时候，就输出新增多少步。</p><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><p>以上所描述的计算和观察属性对全局和局部变量都试用。全局变量定义在任何函数、方法、闭包或者类型上下文的外面。其它情况，都是局部变量。</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性就是平常说的类属性，和类绑定，而和实例无关。</p><p>类属性，同样也可以是变量或者常量。计算类型属性同样也只能是变量，同一般的实例属性一样。</p><h3 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h3><p>定义类属性使用<code>static</code>关键字。对于需要继承的可计算类型属性，可以使用<code>class</code>关键字替代。下面是类属性的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;关联特定类、结构体或枚举的值。Swift主要有存储属性和计算属性。存储属性存储实例的常量或者变量值，然而计算属性主要是计算值（而不是存储值），相当于是附加属性，可以用已有的存储属性计算得到。&lt;/p&gt;
&lt;p&gt;计算和存储属性同样一般是关联特
      
    
    </summary>
    
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之责任链[下]</title>
    <link href="http://yoursite.com/2017/06/27/ChainOfResponsibility2/"/>
    <id>http://yoursite.com/2017/06/27/ChainOfResponsibility2/</id>
    <published>2017-06-27T11:27:29.000Z</published>
    <updated>2017-06-27T02:28:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇责任链的博文说明了责任链模式的定义、模型、应用场景以及优缺点，这一篇说明责任链模式在iOS事件处理中的具体应用 – <em>iOS之响应链</em>（<strong>The Responder Chain</strong>）。</p><img src="/2017/06/27/ChainOfResponsibility2/view_hierarchy.gif" title="视图层次结构图"><a id="more"></a><h1 id="响应者（Responders）"><a href="#响应者（Responders）" class="headerlink" title="响应者（Responders）"></a>响应者（Responders）</h1><p>响应者是一个对象，它能够通过响应链，直接或者间接地接收事件(events)，只需要继承<a href="https://developer.apple.com/documentation/appkit/nsresponder" target="_blank" rel="noopener">NSResponder</a>类，它就是责任链模式中的Handler。iOS Cocoa框架下的很多类：NSApplication, NSWindow, NSDrawer, NSWindowController, NSView等都继承NSResponder。NSResponder类定义了处理事件消息的程序化接口和响应动作的大致结构。响应链上有一个第一响应者和后续的一系列响应者。</p><h1 id="第一响应者（First-Reponders）"><a href="#第一响应者（First-Reponders）" class="headerlink" title="第一响应者（First Reponders）"></a>第一响应者（First Reponders）</h1><p>第一响应者一般是与用户交互的对象，比方说用户选择或者操作鼠标、键盘的操作。它往往是响应链中接收事件或者消息的第一个对象。一个NSWindow对象的第一响应者一般是它自己。但是，当应用程序第一次在设备屏幕上显示窗口的时候，你也可以在程序中或者在Interface Builder中手动设置第一响应者。</p><p>当一个NSWindow对象接收到一个鼠标按下的事件时，它一般会设法把NSView对象设置成第一响应者。它首先会询问当前的view是否愿意成为第一响应者，通过使用acceptsFirstResponder方法。这个方法一般返回NO，想要成为第一响应者的响应者需要重写Responder的这个方法，并且返回Yes。此外，当用户通过键盘接口改变第一响应者的时候，acceptsFirstResponder方法也会被调用。</p><p>你可以通过发送makeFirstResponder:消息给一个NSWindow对象，改变第一响应者。这个消息使得一个对象失去了它的第一响应者身份，而另一个对象成为了第一响应者。</p><p>一个NSPanel对象提供了一种第一响应者行为的变种，它允许面板（panels）获得主窗口（main window）的焦点。假设一个面板现在代表一个非活动(inactive)的窗口，当becomesKeyOnlyIfNeeded 方法接收到一个鼠标按下的事件的时候，它返回一个YES。它尝试将鼠标光标下的视图变为第一响应者。当且仅当调用方法 acceptsFirstResponder和needsPanelToBecomeKey返回YES的时候，才能够成功将光标下的视图变为第一响应者。</p><h1 id="下一个响应者（Next-Responders）"><a href="#下一个响应者（Next-Responders）" class="headerlink" title="下一个响应者（Next Responders）"></a>下一个响应者（Next Responders）</h1><p>每个响应对象都有一个能力，就是获得它在响应链上的下一个响应者，也就是责任链中将消息往前推的默认操作。 响应链的最主要的机制，就是返回响应者对象的nextResponder方法。图3-1显示了下一个响应者的序列。</p><img src="/2017/06/27/ChainOfResponsibility2/responder_chain_2x.png" title="图3-1 响应者链"><p>绝大数的响应链上，一个view的下一个响应者一般是它的superview。实际上，一个窗口的所有视图，由它的第一个响应者到它的内容视图链组成。当你用Interface Builder或者手动写代码创建一个窗口或者在已经存在的视图上添加子视图的时候，Application Kit自动将新建的对象添加到响应链中。NSView对象的addSubView:方法自动将接收者设置成新的子视图的superview。当你想要在这些视图之间插入一个不一样的响应者，必须保证正确地修正整个响应链，以适应新的变化。</p><h1 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h1><p>响应链将一系列的响应对象串联起来，这些响应对象接收事件或者消息的传递。当一个给定的响应对象不处理一个特定的消息的时候，这个对象会将当前消息传递给它在响应链上的继承者（也就是它的下一个响应者）。这就使得响应对象能够代理其他对象的责任，尤其是更高等级的对象。Application Kit按照以下将要说道的方法自动构建响应链，但是你也可以将一般的对象插入到其中。</p><p>一个应用可以包含任何数量的响应链，但是在一个给定的时间，只有一条链是活动的。事件消息和动作消息的响应链是不一样的，下面将详细描述它们的具体操作情况。</p><h2 id="事件消息的响应链"><a href="#事件消息的响应链" class="headerlink" title="事件消息的响应链"></a>事件消息的响应链</h2><p>几乎所有的事件消息都使用一个单一窗口的响应链 – 相关用户事件发生的所在窗口。事件消息的默认响应链从NSWindow第一个传递消息的视图开始。一个键盘按键的默认响应链从一个窗口的第一响应者开始；一个鼠标或者触控板的默认响应链从用户事件发生的视图开始。如果在那儿，事件不被处理，事件消息将会沿着视图层次向前传递。第一个响应者一般是窗口中被选择的视图对象，而且它的下一个响应者是包含它的视图（superview），等等直到NSwindow对象为止。如果一个NSWindowController对象管理这个窗口，它就是最后的响应者。你可以在这些NSView对象之间插入其他响应者，甚至是在NSWindow对象上面，也就是响应链的顶部。这些被插入的响应者既接收事件消息，也接收动作消息。如果没有对象处理事件，那么响应链的最后一个响应者会调用方法noResponderFor:,代表按键按下事件的终止。当然，事件处理对象（一般是NSWindow和NSView的子类）可以重写这个方法，从而执行一些想要执行的附加操作。</p><h2 id="动作消息的响应链"><a href="#动作消息的响应链" class="headerlink" title="动作消息的响应链"></a>动作消息的响应链</h2><p>对于动作信息，Application Kit构建了一个更加详尽的响应链，基于以下两个因素：</p><ul><li>当前应用是否基于文件架构，如果不是，那么它是否使用 NSWindowController 对象构建窗口</li><li>当前应用是否将key window作为主window展示</li></ul><p>由于动作需要更加灵活的运行时机制来决定它们的目标，动作消息拥有更加详细的响应链。它们不像事件消息，仅仅限制在一个窗口中。</p><p>最简单的情况是，一个活动的没有基于文件的窗口，而且没有相关的面板或者次窗口；换句话说，主窗口也是关键窗口(key window)。这种情况下，响应链如下所示：</p><blockquote><ol><li>主窗口的第一响应者和连续的响应对象与视图层次架构一致</li><li>主窗口自己</li><li>主窗口的代理（无需继承NSResponder）</li><li>应用对象，NSApp</li><li>应用对象的代理(无需继承NSResponder)</li></ol></blockquote><p>整条链如图4-1所示</p><img src="/2017/06/27/ChainOfResponsibility2/nondoc_2x.png" title="图4-1 不基于文件应用的动作消息的的响应者链"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文说明了责任链模式在iOS框架Cocoa下的应用 – <strong>响应链</strong>。以及，事件消息和动作消息如何在响应链上传递。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇责任链的博文说明了责任链模式的定义、模型、应用场景以及优缺点，这一篇说明责任链模式在iOS事件处理中的具体应用 – &lt;em&gt;iOS之响应链&lt;/em&gt;（&lt;strong&gt;The Responder Chain&lt;/strong&gt;）。&lt;/p&gt;
&lt;img src=&quot;/2017/06/27/ChainOfResponsibility2/view_hierarchy.gif&quot; title=&quot;视图层次结构图&quot;&gt;
    
    </summary>
    
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP读书笔记 第3章 程序的机器级表示 访问信息</title>
    <link href="http://yoursite.com/2017/06/20/LearningCSAPP/"/>
    <id>http://yoursite.com/2017/06/20/LearningCSAPP/</id>
    <published>2017-06-20T14:14:32.000Z</published>
    <updated>2020-03-28T02:19:08.328Z</updated>
    
    <content type="html"><![CDATA[<p>本文跟随CSAPP新版书，主要针对x86-64架构。</p><h1 id="整数寄存器"><a href="#整数寄存器" class="headerlink" title="整数寄存器"></a>整数寄存器</h1><p>一个x86-64的CPU包含一组16个存储64位值的通用寄存器。这些寄存器用来存储整数数据和指针。图1-1显示了这16个寄存器。</p><img src="/2017/06/20/LearningCSAPP/csapp3_35.JPG" title="图1-1 整数寄存器"><a id="more"></a><p>这16个寄存器的名字都以%r开头，后面跟着一些不同命名规则的名字，是指令集的历史演化造成的。最初的8086有8个16位寄存器，即图1-1中的%ax到%bp。每个寄存器都有特殊的用途，它们的名字就反应了它们的用途，如图1-1中最右边的说明。扩展到IA32架构，即通常说的32位系统，这些寄存器也扩展成为了32位，标号从%eax到%ebp。扩展到现在的x86-64后，原来的8个32位寄存器也扩展到了64位，标号从%rax到%rbp。除此之外，还增加了8个新的寄存器，它们的标号按照新的命名规则：从%r8到%r15.</p><p>如图1-1中嵌套的方框表明，指令可以对这个16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的两个字节，32位可以访问最低的4个字节，而64位操作可以访问整个寄存器。</p><h1 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h1><p>大多数指令有一个或多个操作数(operand)，指示执行一个操作要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式，如图1-2所示。</p><img src="/2017/06/20/LearningCSAPP/operand_format.png" title="图1-2 操作数格式"><p>源数据值可以以常数形式给出，或是从，寄存器或者内存读出。结果可以存放在寄存器或内存中。因此，操作数被分为三类。第一种是立即数(immediate)，用来表示常数值，书写方式是’$‘后面跟一个标准C表示的整数。第二种类型是寄存器(register)，它表示某个寄存器的内容，用r<sub>a</sub>表示任意寄存器a，用引用R[r<sub>a</sub>]表示它的值。第三类操作数是内存引用，它会根据计算出来的地址（通常是有效地址）访问某个内存位置。我们用符号M<sub>b</sub>[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。一般省去下标b。如图1-2有多种不同的寻址模式。</p><h1 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h1><p>C语言程序在调用函数的时候，用到的最常见的操作就是压栈和弹栈操作，理解和熟悉栈操作有助于帮助我们调试函数调用中的一些错误。关于栈的定义和操作这里不详细赘述。在x86-64中，程序栈存放在内存中的某个区域。如图3-1所示，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址最低的。（这里，栈“顶”在图的底部）栈指针%rsp保存着栈顶元素的地址。</p><p>表3-1 入栈和出栈</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">效果</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">pushq    S</td><td style="text-align:center">R[%rsp]  ← R[%rsp]-8; <br> M[R[%rsp]] ← S</td><td style="text-align:center">将四字压入栈</td></tr><tr><td style="text-align:center">popq     D</td><td style="text-align:center">D ← M[R[%rsp]]; <br> R[%rsp] ← R[%rsp]+8</td><td style="text-align:center">将四字弹出栈</td></tr></tbody></table><p>pushq的指令的功能是把数据压入到栈上，而popq的指令是弹出数据。这些指令都只有一个操作数–压入的数据源和弹出的数据目的。</p><p>将一个四字值压入栈中，首先将栈指针减8，然后将值写到新的栈顶地址。因此，pushq %rbp的行为等价于下面两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8, %rsp       将栈指针的值减8</span><br><span class="line">movq %rbp, (%rsp)   将%rbp的值存到内存中</span><br></pre></td></tr></table></figure><p>如图3-1前两栏给出的是，当%rsp为0x108，%rax为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后将0x123存放到内存地址0X100处。</p><img src="/2017/06/20/LearningCSAPP/csapp-stack.png" title="图3-1 栈操作说明"><p>图3-1的第三栏说明的时在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读出值0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值会回到0x108，值0x123仍然会保持在内存位置0x100中，直到被覆盖。无论如何，%rsp指向的地址总是栈顶。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文跟随CSAPP新版书，主要针对x86-64架构。&lt;/p&gt;
&lt;h1 id=&quot;整数寄存器&quot;&gt;&lt;a href=&quot;#整数寄存器&quot; class=&quot;headerlink&quot; title=&quot;整数寄存器&quot;&gt;&lt;/a&gt;整数寄存器&lt;/h1&gt;&lt;p&gt;一个x86-64的CPU包含一组16个存储64位值的通用寄存器。这些寄存器用来存储整数数据和指针。图1-1显示了这16个寄存器。&lt;/p&gt;
&lt;img src=&quot;/2017/06/20/LearningCSAPP/csapp3_35.JPG&quot; title=&quot;图1-1 整数寄存器&quot;&gt;
    
    </summary>
    
    
      <category term="Technology" scheme="http://yoursite.com/categories/Technology/"/>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="计算机" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="汇编" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="寄存器" scheme="http://yoursite.com/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    
  </entry>
  
</feed>
