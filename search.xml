<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[2018年iOS面试总结]]></title>
      <url>/2018/09/20/2018%E5%B9%B4iOS%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>从今年8月初开始找工作到现在，历时一个半月，终于进入了收尾的时候。这一个半月经历了很多，学习了很多，也成长了很多，所以做个总结。总结既是对这一个半月学到的东西，进行一个梳理，也是对未来的一个展望：公司需要的是什么样的人才，看中你的什么？自己需要培养什么技能，需要哪些习惯？本文按照三部分来做总结：第一部分，公司需要什么样的人才；第二部分，自己需要培养什么；第三部分，应聘iOS需要掌握些什么。第三部分，思路是按照第一部分和第二部分的总结，针对iOS需要的一个梳理。本文是从面试iOS的角度出发的，接下来的博文中的一些表达和思考可能会与计算机专业和iOS相关性比较大。</p>
<h1 id="公司需要什么样的人才"><a href="#公司需要什么样的人才" class="headerlink" title="公司需要什么样的人才"></a>公司需要什么样的人才</h1><h2 id="有哪些公司（目标）"><a href="#有哪些公司（目标）" class="headerlink" title="有哪些公司（目标）"></a>有哪些公司（目标）</h2><p>根据我面试的经历，我这边把公司分为四类，A类、B类、C类、D类，知名度和难度都是依次递减。A类是属于技术行业领先、知名度行业领先、公司业务发展行业领先，就我们行业论，BAT自是无话可说（这边不考虑巨头如Google、Facebook），还有已经被人熟知的京东，网易等，以及近几年崛起的如今日头条、滴滴、美团、饿了么等等。B类是，近两年发展很迅速，前景还不错的公司，如拼多多、爱奇艺。C类是已经稳定发展的创业公司，业务和各方面都还不错，资金都很充足。最后一类D类，可能是属于一些创业公司比较初期，或者是一些大公司旗下的子公司，也有可能是一些海外公司在国内拓展业务的子公司，这一类相对来说，人员不是很充足，团队也还需要壮大，一般比较冒险。</p>
<h2 id="公司是怎么样的要求"><a href="#公司是怎么样的要求" class="headerlink" title="公司是怎么样的要求"></a>公司是怎么样的要求</h2><p>这边，都是根据我自己面试经验的总结和推敲，不同类的公司，一般是怎么样的要求，如果有不对或不合理的地方，恳请指正。</p>
<p>由于有些要求是类似的，或者必须的，如果自上而下（A类-&gt;D类）介绍可能会有重复累赘，所以这边自下而上介绍。</p>
<p>首先是D类，这类公司一般会有一个明确的，需要的业务，比方说我面过的一家，是想自己包装一个浏览器，针对用户流量做一些事情。所以它可能会需要至少它业务相关方面的知识储备是有的，比方说对网络协议比较清楚，DNS比较了解。然后你去了，可能也不仅仅是做一个方向的事情，比方说你做APP客户端，如果会后台，也需要帮衬一下，可能相对会有一些杂事。然后，一些框架，前后端的架构，很有可能是用一些比较现成的。总的来说，要求不高，但还是可能会考你一些很基础的东西，简单的算法题，网络和操作系统的一些知识。</p>
<p>接下来是C类，这类公司业务比较成熟，技术团队规模不会太大，但一般都是相对有经验的人。它们的要求，除了你拥有基础以外，更多的可能是，实际经验，业务能力。我觉得，这方面短时间，比较难以补出来，所以还是有一定难度的。它们一般对基础不会问的太深入，但是会给你一个业务场景，需要你去实现这种业务场景。可能更需要的是，你平常对技术有研究，比方说热更新，平常业务可能很少用到，但是你如果去研究这种技术，看相关源码和实现，甚至动手写Demo，做实验，有这样的积累也是不错的。总之，要么你之前的公司很多业务，技术都是比较丰富的，要么自己研究的比较多。</p>
<p>然后再来看B类，这类公司发展和前景都不错，而且处于扩张期，粗放增长。它们对人才的需求量比较大，既有一定的基础，又有大量的业务。所以，对人才一般来说，基础会多看重些，经验可以相对少一些。它们的面试一般，会偏向计算机基础，但是会比较深入，算法要求会比较高。当然，对你所从事的方向的知识，考察的也会比较多。</p>
<p>最后是A类，这一类基本算是TOP了，既然是Top，要求也是Top了。不但对你的计算机基础，算法功底要求很高；对你从事方向的知识掌握也要比较全面；还有对你解决问题的能力要求都比较高。当然，经验充足，基础扎实，技术栈丰富。这些，都是作为一个技术人员，不断追求的目标。<strong>基础</strong>，是解决问题的能力和思路来源；<em>经验</em>，是解决问题的能力体现和积累；技术栈或知识储备，是未来发展方向和Idea的来源。</p>
<h1 id="自己需要培养什么"><a href="#自己需要培养什么" class="headerlink" title="自己需要培养什么"></a>自己需要培养什么</h1><p>总结，上文的公司要求，自己需要培养的能力和积累的东西，主要有: 基础，从事方向基础和原理，经验+及时更新自己的知识库，跟上最新的技术潮流。</p>
<p>首先是基础，计算机基础无非是：操作系统（编译链接），网络，算法和数据结构。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>主要考察最多的是：线程、进程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>考察线程的东西最多</p>
<ol>
<li>线程和进程的区别和联系</li>
<li>多线程的实现方法</li>
<li>如何保证线程安全？加锁有哪几种方式/锁的实现方式有哪些？</li>
<li>死锁是什么？发生的条件？</li>
</ol>
<h3 id="编译连接"><a href="#编译连接" class="headerlink" title="编译连接"></a>编译连接</h3><ol>
<li>C程序是如何一步一步变为可执行文件的？</li>
<li>虚拟内存是什么，一个程序的内存分配是怎么样的？</li>
<li>编译器做的什么？链接期又做的什么？</li>
<li>静态库和动态库的区别？为什么要有动态库？</li>
<li>main函数是什么，为什么C程序的入口默认是main函数？</li>
</ol>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>基础的五层网络模型，TCP三次握手（四次挥手），上层的应用层（比较常见的有HTTP）</p>
<h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h3><ol>
<li>TCP和UDP的区别，哪些场景适合用UDP？</li>
<li>TCP如何进行拥塞避免？</li>
<li>滑动窗口是什么？具体是怎么样的？</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>详细列举一下HTTP的关键知识： HTTP是一种无状态和无连接的协议（原因？）</p>
<ol>
<li>HTTP发送和接收的消息是如何包装的：头部+主体</li>
<li>HTTP头部有哪些组成成分（最主要的是哪些）？</li>
<li>HTTPS和HTTP的区别，HTTPS具体是怎么样实现请求的？</li>
</ol>
<h2 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h2><p>数据结构都是一些常用的，算法是需要不断练，也就是刷题的，这里推荐一些书籍。’</p>
<p>如果你对基础算法还不是很了解，《数据结构与算法分析》，有C语言版和Java版，简单易懂，看完就会对基本的数据结构比较了解，还有一些不太常用的数据结构也有介绍，希尔排序、不相交集、B树等。</p>
<p>如果想要进阶，肯定是《算法导论》，相对比较深奥，难以理解，可以挑自己感兴趣的，比方说，算法导论里的快排，简短精妙，短短几行代码就写完了，而且对复杂度的分析、改版都很透彻。</p>
<p>还有就是一些刷题的OJ，找工作本人比较推荐LeetCode。LeetCode的题分三个等级，Easy\Medium\Hard。如果你很久没写算法题，推荐先从Easy刷起，Easy和Medium的题一般考察的是对基本的算法和数据结构的掌握，所以一般基础相对薄弱的，就刷Easy和Medium就行了；Hard级别的偶尔想要挑战一下的时候，可以试一下。<br>然后刷题有几点建议：1. 推荐C++刷题：C++既需要你对算法有一定的思考（不那么方便），C++又有STL，有一些基本数据结构和算法可以拿来直接用，是锻炼算法的最佳（我认为）语言。 2. 不要用IDE，直接用LeetCode的编辑器：不借助IDE，有助于记住基本的API，忘记了就去cplusplus（C++）查询 ，培养手写代码的能力 3. 尽量自己写出来，实在写不出来，先看Hint；还不行，再看Discuss, 可以找Votes比较高的；最后写完了，或者写不出来，再看Solution。<br>LeetCode还有一个功能就是Tag, 按数据结构分: Tree、Stack、Graph等；所以还有一种思路，你可以先看完《数据结构与算法分析》的某一章，比方说“树”，然后专门刷Tree的题，巩固和提高对它的掌握。</p>
<h1 id="应聘iOS需要掌握些什么"><a href="#应聘iOS需要掌握些什么" class="headerlink" title="应聘iOS需要掌握些什么"></a>应聘iOS需要掌握些什么</h1><p>上面部分主要是作为计算机（IT）面试都需要掌握的知识，只是不同方向，不同公司可能深浅不一，我也只是从我的面试经历总结，可能会有偏颇和遗漏。接下来的部分，是我作为一个iOS开发，面试iOS岗位的一些知识的总结。</p>
<p>我按三个部分来讲，原理，架构和其他，其他部分比较杂，但是是一些做iOS都会用到的知识和技能。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol>
<li>Objective-C Runtime</li>
<li>iOS Runloop</li>
<li>事件响应链</li>
<li>内存管理：MRC，ARC，autorelease</li>
<li>Block</li>
<li>GCD</li>
<li>JSCore(Exception)</li>
</ol>
<h3 id="Objective-C-Runtime"><a href="#Objective-C-Runtime" class="headerlink" title="Objective-C Runtime"></a>Objective-C Runtime</h3><p>最基本的，要对Runtime有一定了解，OC的Runtime是什么？消息是如何转发的？</p>
<p>会问到的一些问题：</p>
<blockquote>
<ol>
<li>你怎么理解OC的动态性?</li>
<li>系统有哪些利用Runtime的应用？（KVO， Category）</li>
<li>KVO是怎么实现的？</li>
<li>Category可以添加方法吗？可以添加属性吗？为什么?</li>
<li>Runtime有哪些应用？</li>
<li>NSProxy了解吗？</li>
<li>RunTime中涉及到的结构体是怎么样的？</li>
</ol>
</blockquote>
<h3 id="iOS-Runloop"><a href="#iOS-Runloop" class="headerlink" title="iOS Runloop"></a>iOS Runloop</h3><p>基本的，要对Runloop了解？Runloop是什么？它的结构是怎么样的？Runloop的内部逻辑（流程）？</p>
<p>会问到的一些问题：</p>
<blockquote>
<ol>
<li>如何把一个任务放到下一个Runloop执行？</li>
<li>为什么Tableview下拉刷新的时候，timer会失效？解决方法？</li>
<li>Timer放在主线程和子线程一样吗？如果不一样，有什么区别？</li>
<li>为什么Timer必须要invalidate?</li>
</ol>
</blockquote>
<h3 id="事件响应链"><a href="#事件响应链" class="headerlink" title="事件响应链"></a>事件响应链</h3><p>基本的，描述iOS事件传递的整个过程？</p>
<p>会问到的一些问题：</p>
<blockquote>
<ol>
<li>有这样一个应用场景。一个应用的Tabbar上，有几个按钮，但是按钮的一部分在Tabbar范围外，如何做到点击按钮Tabbar范围外的地方，也能响应？</li>
<li>给一个Tableview的Cell添加手势，事件响应链会有怎么样的变化？会先响应手势呢，还是Cell会先响应？</li>
<li>UIControl在事件响应链中的作用，以及它的优先级？</li>
</ol>
</blockquote>
<h3 id="内存管理：MRC，ARC，autorelease"><a href="#内存管理：MRC，ARC，autorelease" class="headerlink" title="内存管理：MRC，ARC，autorelease"></a>内存管理：MRC，ARC，autorelease</h3><p>内存管理，基本的，iOS的内存管理是怎么样的?然后比较多问的，是问OC属性相关引发的问题</p>
<p>会问到的一些问题：</p>
<blockquote>
<ol>
<li>OC的属性中，哪些和内存相关？</li>
<li>哪些类型需要用copy属性？</li>
<li>assign一般修饰什么？它可以修饰对象吗？</li>
<li>strong和weak的区别？weak是如何实现的？</li>
<li>如何避免循环引用？</li>
<li>weak和unsafe_unretained有什么区别？什么情况下会用到unsafe_unretained？</li>
<li>autoreleasepool了解吗？什么情况下会需要用到？</li>
</ol>
</blockquote>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>基本的，Block是什么,为什么要有Block？Block是如何实现的？它放在内存的哪个区域？</p>
<p>会问到的一些问题：</p>
<blockquote>
<ol>
<li>什么情况下需要用<strong>block，</strong>block是如何实现的，对应的对象是放在堆上还是栈上？</li>
<li>block会造成循环引用吗？什么情况下会造成？有哪些方法解决循环引用？</li>
<li>block为何一般需要copy属性？</li>
</ol>
</blockquote>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD和多线程相关，所以会问一些线程相关的东西引入。比方说iOS有哪几种多线程的方式？OperationQueue和GCD的区别？GCD的优势和劣势？</p>
<p>会问到的一些问题：</p>
<blockquote>
<ol>
<li>如何理解dispatch_async和dispatch_sync？</li>
<li>什么情况下会用到dispatch_group？</li>
<li>如何理解串行队列和并行队列？它是怎么实现的？</li>
<li>main_queue和global_queue是什么？分别是串行的，还是并行的？</li>
<li>如果一个通知在global_queue中添加observer，然后又再main_queue中发送通知，那么这个通知的任务最后在主线程，还是子线程执行？</li>
<li>dispatch_once是如何保证原子性的？</li>
<li>每创建一个新的队列就会产生一个新的线程吗？线程数量是有限的吗？如果要你定一个线程池的大小，你会选择多大？理由？</li>
</ol>
</blockquote>
<h3 id="JSCore"><a href="#JSCore" class="headerlink" title="JSCore"></a>JSCore</h3><p>JSCore相比于前面的原理不是那么重要，但是很多与JS打交道的东西都和它有关，比方说热更新的一些方案，JS_bridge的实现方案，RN、Weekx，都是基于它的；还有，最基本的，iOS的浏览器内核，主要是WebKit，主要的组成就是JSCore。主要是要搞清楚Webkit的组成，JSCore在其中扮演的角色，它是干什么的?</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>iOS主要架构有MVC、MVP、MVVM，还有VIPER。可以找一些相关的博文深入理解和分析一下。关于MVVM，推荐Limboy的博客，介绍MVVM和使用RAC实现MVVM讲得很详细。</p>
<p>可能会问的问题：</p>
<ol>
<li>你怎么理解MVC和MVVM？</li>
<li>我们知道RxSwift可以很容易实现数据的绑定，那么你知道它的原理吗？它是基于RAC的，对RAC的实现了解吗？</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>组件化</li>
<li>热更新</li>
<li>持续化集成（CI）</li>
<li>设计模式</li>
<li>第三方库</li>
</ol>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化是17年比较火的一个概念，最早是由蘑菇街的Limboy提出组件化的方案和思路，然后Casa针对Limboy的方案提出一些改进和建议的思路，并给出了简单的Demo, 然后Bang在前三篇文章基础之上做了清晰的总结；然后，就掀起了一片讨论和热潮。我这边就不详细讨论了，研究得也还不是很透彻，所以，就简单贴几个链接。如果作者觉得侵权了，可以随时联系我删除。</p>
<ol>
<li><a href="http://limboy.me/tech/2016/03/10/mgj-components.html" target="_blank" rel="external">蘑菇街组件化之路</a></li>
<li><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">iOS应用架构谈 组件化方案</a></li>
<li><a href="http://limboy.me/tech/2016/03/14/mgj-components-continued.html" target="_blank" rel="external">蘑菇街 App 的组件化之路·续</a></li>
<li><a href="http://blog.cnbang.net/tech/3080/" target="_blank" rel="external">iOS 组件化方案探索</a></li>
</ol>
<h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>热更新，是利用Objective-C的动态性，加上JSCore，实现对已有代码的更新和修复。所以，主要利用了OC的runtime和JSCore实现。使用最广泛第三方库实现是JSPatch，作者有对它实现整个库的过程和原理，有详细的博文说明。通过阅读它的源码和分析，基本上可以对热更新这一技术有一个比较全面的了解。</p>
<h3 id="持续化集成（continue-integrate）"><a href="#持续化集成（continue-integrate）" class="headerlink" title="持续化集成（continue integrate）"></a>持续化集成（continue integrate）</h3><p>持续化集成，是一个能够极大提高生产效率的一个思路。由于，很多公司的项目庞大，编译一次可能耗时几小时，甚至几天的时间。所以，能够在合适的时间自动编译，自动部署可以大幅度的减少一些重复和不必要的工作。目前iOS用的比较多的，有Jenkins和Fastlane。本人研究还不够深入，所以暂时不详细阐述。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>设计模式，其实面是向对象开发过程中，为了提高代码的复用性、可读性和可靠性，一套被反复使用的、许多程序猿验证使用、并梳理分类过的总结。苹果在iOS系统上，自己本身就应用了很多常见的设计模式。关于设计模式，网上介绍的有一大堆，但真实能否用起来，理解可能光看这些还不够。</p>
<p>我这边推荐一本书，《设计模式:可复用面向对象软件的基础(英文版)》，它囊括了基本所有常见的设计模式，而且每个设计模式，都是按目的、动机、结构、应用场景、优缺点和实际例子，还有常见的具体应用来讲述的。稍稍有点比较晦涩难懂，是因为它需要一定的抽象能力，但是你一旦理解了，对这个设计模式掌握得也就比较透彻了。书中的例子都是用C++写的，想必程序员对C++都应该不会陌生。</p>
<h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>第三方库，平常开发过程中经常会用到第三方库，由于它们的各种优点：易用、安全、高效等。其实，一些优秀的第三方库有很多值得我们学习和借鉴的地方，平常如果经常阅读它们的源代码可以学到很多东西。它们实现某个功能的思路，和解决问题的方法，还有一些良好的代码习惯，甚至是应对一些小点的一些Trick。有些第三方库的作者，不仅开源它们的代码，还自己写博客分析它们的库和写库的经历。作为一个程序员，学习和模仿是必备技能，而阅读第三方库，是一个相对比较高效和受益颇多的方法。</p>
<p>扯完淡，讲点实在的，简单介绍一下iOS常用的第三方库。</p>
<p>AFNetwork，客户端与后台、或固件的交互都是基于网络请求的，苹果系统自带就有网络请求库，URLConnection、URLSession，那么既然系统自带，为什么不用系统的呢？通过阅读AFNetwork，你能知道一个HTTP请求构成，需要哪些步骤，消息如何封装，还能看到它使如何处理和安排上层的多个请求的，还能够大致了解和掌握HTTPS的一个过程。</p>
<p>YYCache，YYCache的作者，自己就有分享它写这个库的过程和考量，以及自己解决问题的思路和最后的方案。通过学习YYCache，你可以对缓存设计有一定的思路和了解。</p>
<p>JSPatch，热更新的一个广泛备用的开源库。这个库的作者，也详细介绍了它写这个库的初衷，想法，初始设计和存在问题、解决问题的过程。通过他的介绍，你会对这种热更新有个全面的认识，也会对JS和客户端交互的一些方法有些了解，还有更加体会到OC Runtime的好处和精髓。</p>
<p>然后，还有很多很多，优秀的库值得我们学习。。。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>最后，写一些这一趟面试下来，觉得作为一个程序员需要培养注意的东西和养成的一些习惯，主要是用来提醒自己，和同样需要在这个方向不断前行的小伙伴。</p>
<blockquote>
<ol>
<li>多逛社区，阅读博客，跟上最新的技术潮流，学习新的技术</li>
<li>多看开源库，学习优秀代码</li>
<li>多写代码实践和验证一些理论，积攒经验和掌握理论</li>
<li>多做题，锻炼自己解决问题和巩固算法数据结构</li>
<li>多写博客，总结、分享自己的工作和研究</li>
<li>多和其他技术人员交流，分享自己的学习和知识（多写PPT演讲）</li>
</ol>
</blockquote>
<p> 最后的最后，感谢你看到这儿，有什么问题，欢迎指出和纠正；有什么建议，欢迎提出和讨论。<br> 我的Email地址: huanjianjiang@gmail.com</p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> iOS开发 </tag>
            
            <tag> 应用 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift下的状态设计模式（State Pattern）]]></title>
      <url>/2018/06/11/SwiftStatePattern/</url>
      <content type="html"><![CDATA[<p>  如果你的对象拥有许多状态，那么你或许可以考虑一下使用<strong>状态</strong>模式。在这篇博文中，我们将覆盖到一些关于<em>状态</em>模式的一些理论，然后会以一个列子说明如何实现它。希望，阅读完这篇文章以后，你会比较熟悉<em>状态</em>设计模式。</p>
<h2 id="状态设计模式"><a href="#状态设计模式" class="headerlink" title="状态设计模式"></a>状态设计模式</h2><p>当你在做项目的时候，很有可能碰到一个类有很多内部状态。举个栗子，比方说你有一个从服务器下载大图的类。这个类就有可能处于好几种不同的状态：请求中、下载中、处理中、保存中、、、等等。</p>
<p>在我们的例子中我们将使用一辆汽车。我们的汽车可以处于停止的状态，它也能够处于移动中、或者自动停车状态。这辆汽车将会有它的功能，比方说刹车和停车。根据汽车所处的状态，使用不同的功能将会有不一样的效果。如果对停止状态的汽车发送刹车指令，将没有任何效果；而对一个正在自动停车状态的车发送刹车指令，将会使汽车取消它的停车操作。</p>
<p>这辆汽车能够内部控制它自己的状态，我们不需要知道，或者无须关心它到底处于什么状态。从本文前面的说明，你知道，调用同一个功能，但对象处于不同的状态的时候，会产生不一样的结果。这也给我们带来了<strong>状态</strong>设计模式的定义如下：</p>
<blockquote>
<p><em>状态设计模式允许一个对象在它的内部状态改变的时候，改变它自己的行为。这个对象看起来好像能够改变它的类型</em>。</p>
</blockquote>
<p>到这里为止，已经足够覆盖状态设计模式的理论。接下来，让我们先看一下几幅图表。</p>
<h2 id="汽车状态"><a href="#汽车状态" class="headerlink" title="汽车状态"></a>汽车状态</h2><p>我们将要在一个汽车类上实现“状态设计模式”。我们的汽车将会有三个不一样的状态，如图1-1</p>
<img src="/2018/06/11/SwiftStatePattern/states.jpg" alt="图1-1" title="图1-1">
<p>汽车能够改变状态，但是有几个规则需要遵守。例如，你不能直接从移动状态变为停车状态，你需要先转换到停止状态。</p>
<p>如果你正在思考如何将汽车的这些行为实现到你的汽车类当中，你也许会想到用一个枚举来存储汽车类的状态信息。想象一下你的函数将会是怎么样的，你的代码中会出现很多switch cases。你的汽车类将会变的相当庞大，并且会难以维护。</p>
<p>我们将要做的是，将每个’cases’或者状态独立成它自己的一个类。汽车类将会有一个对当前状态的引用。这将允许它们控制汽车的当前状态。下面图1-2，是一个关于我们类的层次的简要图。</p>
<img src="/2018/06/11/SwiftStatePattern/classdiagram.jpg" alt="图1-2" title="图1-2">
<p>让我们具体来研究一下它，并且开始着手写代码。。。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们将会尽量保持代码简单，便于理解。我们的汽车类将会有三个函数，一个用来存储速度的变量和一些创建状态的工厂方法；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">VehicleProtocol</span>: <span class="title">class</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// MARK: - Vehicle State</span></div><div class="line">    <span class="keyword">var</span> speed: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">setState</span><span class="params">(<span class="number">_</span> state: VehicleState)</span></span></div><div class="line">    </div><div class="line">    <span class="comment">// MARK: - Vehicle Controls</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span></div><div class="line">    </div><div class="line">    <span class="comment">// MARK: - State Getters</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getStoppedState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getMovingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getParkingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个使用汽车的类，一般情况下只能通过调用‘vehicle controls’中的函数的方式，与汽车交互。 其他的函数/变量只能被状态类使用。</p>
<p>调用任何控制函数只是简单的将汽车转变为目标状态，而当前的汽车状态会具体处理需要做的事情；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</div><div class="line">    state?.accelerate()</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</div><div class="line">    state?.brake()</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</div><div class="line">    state?.park()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的汽车使用工厂方法来创建汽车状态；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MARK: - State Getters</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStoppedState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">StoppedState</span>(<span class="keyword">self</span>)</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMovingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">MovingState</span>(<span class="keyword">self</span>)</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">getParkingState</span><span class="params">()</span></span> -&gt; <span class="type">VehicleState</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="type">ParkingState</span>(<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你将在这里开始看到模式的合并，也就是将所有状态串起来（不知道这么说合不合适）。每个状态类有一个指回汽车的指针，而且它能够创建新的状态。到现在为止，就差一口气了，那就是实现这些状态类。</p>
<h2 id="状态类（State-Classes）"><a href="#状态类（State-Classes）" class="headerlink" title="状态类（State Classes）"></a>状态类（State Classes）</h2><p>我们将针对我们的汽车状态使用一个协议（Protocol）:<br>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">VehicleState</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  每个状态函数都会有一个指回汽车类的引用。并且每个状态类将会实现汽车的控制函数。我们将会在接下来的瞬间看到，每个不一样的状态类，调用汽车的（可能是相同的）控制函数，将会有不同的意义和作用。</p>
<h3 id="停止状态（Stopped）"><a href="#停止状态（Stopped）" class="headerlink" title="停止状态（Stopped）"></a>停止状态（Stopped）</h3><p>  让我们先看一下最简单的状态，停止状态；</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StoppedState</span>: <span class="title">VehicleState</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle: <span class="type">VehicleProtocol</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.vehicle = vehicle</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.vehicle?.speed += <span class="number">5</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> movingState = <span class="keyword">self</span>.vehicle?.getMovingState() &#123;</div><div class="line">            <span class="keyword">self</span>.vehicle?.setState(movingState)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Can't brake... Vehicle is already stopped!"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> parkingState = <span class="keyword">self</span>.vehicle?.getParkingState() &#123;</div><div class="line">            <span class="keyword">self</span>.vehicle?.setState(parkingState)</div><div class="line">            parkingState.park()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  当汽车在停止状态的时候，调用‘accelerate’方法，将会提高汽车的速度5（kph，具体多少并不重要）。它同时也会使得汽车进入新的状态，也就是移动状态。调用‘brake’函数不会有任何作用，因为汽车已经本来就是停止状态。而调用‘park’函数将会使得汽车进入自动停车的过程。</p>
<h3 id="停车状态（Parking）"><a href="#停车状态（Parking）" class="headerlink" title="停车状态（Parking）"></a>停车状态（Parking）</h3><p>停车状态稍微有点意思；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParkingState</span>: <span class="title">VehicleState</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle: <span class="type">VehicleProtocol</span>?</div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> parking: <span class="type">Bool</span> = <span class="literal">false</span></div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.vehicle = vehicle</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Vehicle is automatically parking, you can't accelerate!"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Automatic parking has been aborted"</span>)</div><div class="line">        stopParking()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">self</span>.parking == <span class="literal">false</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Vehicle is already parking"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Vehicle is now parking"</span>)</div><div class="line">        <span class="keyword">self</span>.parking = <span class="literal">true</span></div><div class="line">        <span class="type">DispatchQueue</span>.global().asyncAfter(deadline: .now() + <span class="number">5</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.stopParking()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">stopParking</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Vehicle has stopped parking"</span>)</div><div class="line">        <span class="keyword">self</span>.parking = <span class="literal">false</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> stoppedState = <span class="keyword">self</span>.vehicle?.getStoppedState() &#123;</div><div class="line">            <span class="keyword">self</span>.vehicle?.setState(stoppedState)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们可以看到‘brake’函数将会停止汽车的停车过程。有趣的是，调用‘park’函数将会引发一系列的事件。你可以对这个方法的内容提出异议，也就是针对‘停止状态’可以有更好的方法，但是为了简单起见，让我们暂时保持这样（Take it easy!）。</p>
<h3 id="移动状态（Moving）"><a href="#移动状态（Moving）" class="headerlink" title="移动状态（Moving）"></a>移动状态（Moving）</h3><p>移动状态也同样非常简单；</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingState</span>: <span class="title">VehicleState</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> vehicle: <span class="type">VehicleProtocol</span>?</div><div class="line">    </div><div class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="number">_</span> vehicle: <span class="type">VehicleProtocol</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.vehicle = vehicle</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">accelerate</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.vehicle?.speed += <span class="number">5</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">brake</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">self</span>.vehicle?.speed -= <span class="number">5</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.vehicle?.speed == <span class="number">0</span>, <span class="keyword">let</span> stoppedState = <span class="keyword">self</span>.vehicle?.getStoppedState() &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Vehicle braked to a stop"</span>)</div><div class="line">            <span class="keyword">self</span>.vehicle?.setState(stoppedState)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">park</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Can't park the vehicle while it's moving. You need to stop first"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以在这里看到，我们在‘brake’函数中有一小段不一样的逻辑，就是，如果速度掉到0，将会使得汽车进入到停止状态。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>让我们迫不及待的测试一下，我们的汽车：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">testVehicle</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> vehicle = <span class="type">Vehicle</span>()</div><div class="line">    vehicle.brake()</div><div class="line">    vehicle.accelerate()</div><div class="line">    vehicle.accelerate()</div><div class="line">    vehicle.brake()</div><div class="line">    vehicle.park() <span class="comment">// prints: Can't park the vehicle while it's moving. You need to stop first</span></div><div class="line">    vehicle.brake()</div><div class="line">    vehicle.park()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，我们第一次调用‘park’方法将会打印出一条消息，意思是“汽车必须是停止状态，才能够停车”，当我们刹车以后，第二次调用，才会产生预期的结果。这个简单的测试表现出了我们的汽车是如何在运行中改变状态的。调用同一个类实例的同一个方法会产生不一样的结果。哈哈，这就是<strong>状态</strong>模式的精髓。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你看到一个类有很多的<code>switch-case</code>语句的时候，就表示你可以考虑一下使用状态模式。我们可以很简单的使用枚举来表示汽车的当前状态。但是函数会变得很庞大，业务逻辑将会出现在case代码快里边，代码很有可能会变得杂乱而难以维护。这个简单的设计模式也许能够轻松的解决这个问题。当然，随着项目的发展，你会有很多很多的类，类的层次会很复杂。但是别担心，用了状态模式，你的代码照样能够易于理解，可扩展。不信，你可以试一试！毕竟没有什么损失。</p>
<p>我希望今天你能在这学到一些新东西，新知识。<br>和往常一样，希望有一个开心的日子😊</p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> iOS开发 </tag>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步和异步]]></title>
      <url>/2018/01/25/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><p>假设你有两个任务，任务A和B：A先执行，B后执行。<br>同步意味着，当你要执行任务B的时候，你必须要等到任务A执行完成，才能执行任务B, 也就是顺序执行。异步意味着，你执行A一段时间以后，但是还没有结束，你可以先执行任务B。</p>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>技术上讲，同步/异步的概念跟线程其实不相关。尽管，很少有异步的任务在单线程上跑，但是还是有可能的，两个或更多任务在同一线程上异步执行。同步/异步的概念仅仅与，是否有第二个或者接下来的任务能在其他（第一个）任务完成前开始执行，或者它是不是必须等待。其他不管什么线程、进程、CPU，或者实际上的什么硬件都没有关系。</p>
<p>同步/异步的不准确解释：</p>
<blockquote>
<ol>
<li>同步意味着两个或者多个任务在同一个上下文（线程）运行，所以一个任务或阻塞另一个任务</li>
<li>同步意味着两个或者多个任务顺序的发生</li>
<li>异步意味着两个或者多个任务在不同的上下文（线程）运行，所以它们可以并发执行而不会互相阻塞</li>
<li>异步意味着两个或者多个任务异步地发生</li>
<li>等等。。。</li>
</ol>
</blockquote>
<h3 id="异步代码可能运行或者可能不运行在同一线程中"><a href="#异步代码可能运行或者可能不运行在同一线程中" class="headerlink" title="异步代码可能运行或者可能不运行在同一线程中"></a>异步代码可能运行或者可能不运行在同一线程中</h3><h3 id="同步操作能够顺序地执行，也能够同步执行"><a href="#同步操作能够顺序地执行，也能够同步执行" class="headerlink" title="同步操作能够顺序地执行，也能够同步执行"></a>同步操作能够顺序地执行，也能够同步执行</h3><h2 id="异步可能出现情况"><a href="#异步可能出现情况" class="headerlink" title="异步可能出现情况"></a>异步可能出现情况</h2><ol>
<li>磁盘I/O</li>
<li>网络请求</li>
<li>DMA（直接内存存取）</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol>
<li><a href="https://codewala.net/2015/07/29/concurrency-vs-multi-threading-vs-asynchronous-programming-explained/" target="_blank" rel="external">Concurrency vs Multi-threading vs Asynchronous Programming : Explained</a></li>
<li><a href="https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean" target="_blank" rel="external">Stackoverflow: Asynchronous vs synchronous execution</a></li>
<li><a href="https://www.javatpoint.com/understanding-synchronous-vs-asynchronous" target="_blank" rel="external">Synchronous vs Asynchronous Under Web-Application</a></li>
<li><a href="https://www.codeproject.com/Articles/127660/What-are-actually-synchronous-asynchronous-operati" target="_blank" rel="external">Code Project:What are Actually Synchronous/Asynchronous Operations</a></li>
<li><a href="https://www.safaribooksonline.com/library/view/linux-system-programming/0596009585/ch04s05.html" target="_blank" rel="external">O’REILLY Linux System Programming: Synchronized, Synchronous, and Asynchronous Operations</a></li>
<li>[Programmr:The difference between asynchronous and non-blocking] (<a href="http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking" target="_blank" rel="external">http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking</a>)</li>
<li><a href="https://www.google.co.id/search?q=asynchronous+programming&amp;safe=active&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjwiaPK6c7VAhVFpI8KHQ7-CWQQ_AUICygC&amp;biw=1680&amp;bih=858#imgrc=TXJCeZEAG_CE-M" target="_blank" rel="external">https://www.google.co.id/search?q=asynchronous+programming&amp;safe=active&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwjwiaPK6c7VAhVFpI8KHQ7-CWQQ_AUICygC&amp;biw=1680&amp;bih=858#imgrc=TXJCeZEAG_CE-M</a>:</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift 属性]]></title>
      <url>/2017/12/07/Swift%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<p><strong>属性</strong>关联特定类、结构体或枚举的值。Swift主要有存储属性和计算属性。存储属性存储实例的常量或者变量值，然而计算属性主要是计算值（而不是存储值），相当于是附加属性，可以用已有的存储属性计算得到。</p>
<p>计算和存储属性同样一般是关联特定类型的实例。然而，属性同样能够和类型本身关联。这样的属性叫做类型属性。</p>
<p>此外，你还能够定义属性观察器来监视属性值的变化，利用它，你可以写一些响应的操作。属性观察器既能够自己定义，也能够从父类当中继承得到。</p>
<h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>存储属性，最简单的形式，就是存储在一个特定的类或机构体的实例中的，一个常量或变量。存储属性既可以是变量（由关键字<code>var</code>定义），也可以是常量（由关键字<code>let</code>定义）。</p>
<p>下面的例子，定义了一个结构FixedLengthRange，描述了一个整型数据的范围，其中的范围长度创建以后就不能改变。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></div><div class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</div><div class="line"><span class="comment">// the range represents integer values 0, 1, and 2</span></div><div class="line">rangeOfThreeItems.firstValue = <span class="number">6</span></div><div class="line"><span class="comment">// the range now represents integer values 6, 7, and 8</span></div></pre></td></tr></table></figure>
<h3 id="常量结构体实例的存储属性"><a href="#常量结构体实例的存储属性" class="headerlink" title="常量结构体实例的存储属性"></a>常量结构体实例的存储属性</h3><p>假如你创建了一个结构体实例，并将它赋给一个常量，那么你就不能改变这个实例的属性，包括变量属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)</div><div class="line">// this range represents integer values 0, 1, 2, and 3</div><div class="line">rangeOfFourItems.firstValue = 6</div><div class="line">// this will report an error, even though firstValue is a variable property</div></pre></td></tr></table></figure>
<p>因为<code>rangeOfFourItems</code>被声明为一个常量，所以不可能改变它的<code>firstValue</code>属性，尽管它是一个变量属性。</p>
<p>这个行为是因为结构体属于<em>值类型</em>。值类型的实例如果标记为常量，那么它的所有属性都是常量。</p>
<p>这中情况对类并不适用，类是<em>引用类型</em>。假如你将一个引用类型的实例赋给一个常量，你仍然可以改变实例的变量属性。</p>
<h3 id="懒（加载）存储属性"><a href="#懒（加载）存储属性" class="headerlink" title="懒（加载）存储属性"></a>懒（加载）存储属性</h3><p>懒属性就是一种属性，直到它第一次被使用，它的值才会被计算。</p>
<blockquote>
<p>注意点<br><strong>懒属性必须声明为一个变量，因为它的初始值不会被用到，在实例初始化完成后。而常量属性必须在初始化完成以后有值，因此它不能被声明为懒属性</strong></p>
</blockquote>
<p>懒属性在以下情况下非常有用：它的值依赖于外在因素，也就是实例初始化完以后，这些外在因素还不知道的情况。还有就是，属性的值计算非常复杂或者计算代价非常高。只有使用它的时候去计算最好。</p>
<p>下面例子，利用懒存储属性，避免一个复杂类的不必要初始化。这个例子定义两个类<code>DataImporter</code>和<code>DataManager</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     DataImporter is a class to import data from an external file.</div><div class="line">     The class is assumed to take a nontrivial amount of time to initialize.</div><div class="line">     */</div><div class="line">    <span class="keyword">var</span> filename = <span class="string">"data.txt"</span></div><div class="line">    <span class="comment">// the DataImporter class would provide data importing functionality here</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</div><div class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</div><div class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</div><div class="line">    <span class="comment">// the DataManager class would provide data management functionality here</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</div><div class="line">manager.data.append(<span class="string">"Some data"</span>)</div><div class="line">manager.data.append(<span class="string">"Some more data"</span>)</div><div class="line"><span class="comment">// the DataImporter instance for the importer property has not yet been created</span></div></pre></td></tr></table></figure>
<p><code>DataManager</code>类用来管理属性<code>data</code>, 一个<code>String</code>数组。</p>
<p><code>DataManager</code>的部分功能是从文件当中获取<code>data</code>。然后这个功能是由类<code>DataImporter</code>提供的，需要花费相当多的时间进行初始化。这可能是因为<code>DataImporter</code>实例需要打开文件，将文件内容读入到内存等等。</p>
<p>但是使用了懒属性，使用<code>lazy</code>标记，<code>importer</code>属性对应的<code>DataImporter</code>实例，只有当<code>importer</code>属性第一次被使用的时候才会被创建，比方说它的文件名被访问的时候；<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(manager.importer.filename)</div><div class="line"><span class="comment">// the DataImporter instance for the importer property has now been created</span></div><div class="line"><span class="comment">// Prints "data.txt"</span></div></pre></td></tr></table></figure></p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>除了存储属性，类，结构体和枚举也能够定义<em>计算属性</em>，它实际上不存储一个值。相反，它们提供一个获取和可选的设置，用来直接检索或设置属性和值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</div><div class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</div><div class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</div><div class="line">        <span class="keyword">get</span> &#123;</div><div class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</div><div class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</div><div class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">set</span>(newCenter) &#123;</div><div class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</div><div class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</div><div class="line">                  size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</div><div class="line"><span class="keyword">let</span> initialSquareCenter = square.center</div><div class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (\(square.origin.x), \(square.origin.y))"</span>)</div><div class="line"><span class="comment">// Prints "square.origin is now at (10.0, 10.0)"</span></div></pre></td></tr></table></figure>
<p>这个例子定义来地理形状的三个结构：</p>
<ul>
<li><code>Point</code>封装了一个点的x-和y-坐标</li>
<li><code>Size</code>封装了长度和宽度</li>
<li><code>Rect</code>定义了一个长方形通过一个原点的点和尺寸</li>
</ul>
<p><code>Rect</code>结构同样提供了一个计算属性<code>center</code>。这个属性可以依赖orgin和size算出来，设置它，可以通过size，改变origin。也就是计算属性，主要是提供一些不是最原始的属性，但是又可以方便用户使用和设置的一种属性。</p>
<h3 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h3><p>计算属性只有获取（getter）就叫做只读计算属性。只读计算属性经常返回一个值，所以可用<strong>点</strong>的语法获取。</p>
<p>同样，可以用简写的形式，去掉<code>get</code>关键字和它的大括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span></div><div class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</div><div class="line">        <span class="keyword">return</span> width * height * depth</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)"</span>)</div><div class="line"><span class="comment">// Prints "the volume of fourByFiveByTwo is 40.0"</span></div></pre></td></tr></table></figure>
<h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器观察并对属性值的变化作出响应。属性观察器，在每一次属性值设置的时候都会被调用，即使新的属性值和现在的值一样。</p>
<p>你可以给任何存储属性添加属性观察器，除了懒加载存储属性。你也可以给任何继承的属性添加属性观察器，通过在子类中重写属性。</p>
<p>你可以针对一个属性，定义单个或者同时定义两个观察器。</p>
<ul>
<li><code>willSet</code>在值被存储前被调用</li>
<li><code>disSet</code>在新值存储后立即被调用</li>
</ul>
<p>如果你实现一个<code>willSet</code>观察器，它会被传递新的属性值作为常量参数，并且你可以对这个人参数指定一个名字。如果你不指定名字，这个参数的默认名字为<code>newValue</code>。</p>
<p>类似的，如果你实现<code>disSet</code>观察器，它会被传递一个常量参数，包含的是先前的值。你同样可以为这个参数命名，或者使用默认值<code>oldValue</code>。</p>
<p>接下来，是一个<code>willSet</code>和<code>disSet</code>的例子。这个例子，是一个<code>StepCounter</code>的类，用来记步，它用一个变量<code>totalSteps</code>来记录当前的步数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"About to set totalSteps to \(newTotalSteps)"</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">didSet</span> &#123;</div><div class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</div><div class="line">                <span class="built_in">print</span>(<span class="string">"Added \(totalSteps - oldValue) steps"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</div><div class="line">stepCounter.totalSteps = <span class="number">200</span></div><div class="line"><span class="comment">// About to set totalSteps to 200</span></div><div class="line"><span class="comment">// Added 200 steps</span></div><div class="line">stepCounter.totalSteps = <span class="number">360</span></div><div class="line"><span class="comment">// About to set totalSteps to 360</span></div><div class="line"><span class="comment">// Added 160 steps</span></div><div class="line">stepCounter.totalSteps = <span class="number">896</span></div><div class="line"><span class="comment">// About to set totalSteps to 896</span></div><div class="line"><span class="comment">// Added 536 steps</span></div></pre></td></tr></table></figure>
<p>这个类用一个变量<code>totalSteps</code>来记录当前的步数。无论什么时候，只要属性被赋予新值，其中的<code>willSet</code>和<code>disSet</code>观察器都会被调用。<code>willSet</code>中，每次都会输出新的步数。而在<code>didSet</code>中，当新的步数超过旧的步数的时候，就输出新增多少步。</p>
<h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><p>以上所描述的计算和观察属性对全局和局部变量都试用。全局变量定义在任何函数、方法、闭包或者类型上下文的外面。其它情况，都是局部变量。</p>
<h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>类型属性就是平常说的类属性，和类绑定，而和实例无关。</p>
<p>类属性，同样也可以是变量或者常量。计算类型属性同样也只能是变量，同一般的实例属性一样。</p>
<h3 id="类型属性语法"><a href="#类型属性语法" class="headerlink" title="类型属性语法"></a>类型属性语法</h3><p>定义类属性使用<code>static</code>关键字。对于需要继承的可计算类型属性，可以使用<code>class</code>关键字替代。下面是类属性的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">6</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">27</span></div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">107</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> iOS开发 </tag>
            
            <tag> 应用 </tag>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之责任链[下]]]></title>
      <url>/2017/06/27/chain-of-responsibility-2/</url>
      <content type="html"><![CDATA[<p>上一篇责任链的博文说明了责任链模式的定义、模型、应用场景以及优缺点，这一篇说明责任链模式在iOS事件处理中的具体应用 – <em>iOS之响应链</em>（<strong>The Responder Chain</strong>）。</p>
<img src="/2017/06/27/chain-of-responsibility-2/view_hierarchy.gif" alt="视图层次结构图" title="视图层次结构图">
<a id="more"></a>
<h1 id="响应者（Responders）"><a href="#响应者（Responders）" class="headerlink" title="响应者（Responders）"></a>响应者（Responders）</h1><p>响应者是一个对象，它能够通过响应链，直接或者间接地接收事件(events)，只需要继承<a href="https://developer.apple.com/documentation/appkit/nsresponder" target="_blank" rel="external">NSResponder</a>类，它就是责任链模式中的Handler。iOS Cocoa框架下的很多类：NSApplication, NSWindow, NSDrawer, NSWindowController, NSView等都继承NSResponder。NSResponder类定义了处理事件消息的程序化接口和响应动作的大致结构。响应链上有一个第一响应者和后续的一系列响应者。</p>
<h1 id="第一响应者（First-Reponders）"><a href="#第一响应者（First-Reponders）" class="headerlink" title="第一响应者（First Reponders）"></a>第一响应者（First Reponders）</h1><p>第一响应者一般是与用户交互的对象，比方说用户选择或者操作鼠标、键盘的操作。它往往是响应链中接收事件或者消息的第一个对象。一个NSWindow对象的第一响应者一般是它自己。但是，当应用程序第一次在设备屏幕上显示窗口的时候，你也可以在程序中或者在Interface Builder中手动设置第一响应者。</p>
<p>当一个NSWindow对象接收到一个鼠标按下的事件时，它一般会设法把NSView对象设置成第一响应者。它首先会询问当前的view是否愿意成为第一响应者，通过使用acceptsFirstResponder方法。这个方法一般返回NO，想要成为第一响应者的响应者需要重写Responder的这个方法，并且返回Yes。此外，当用户通过键盘接口改变第一响应者的时候，acceptsFirstResponder方法也会被调用。</p>
<p>你可以通过发送makeFirstResponder:消息给一个NSWindow对象，改变第一响应者。这个消息使得一个对象失去了它的第一响应者身份，而另一个对象成为了第一响应者。</p>
<p>一个NSPanel对象提供了一种第一响应者行为的变种，它允许面板（panels）获得主窗口（main window）的焦点。假设一个面板现在代表一个非活动(inactive)的窗口，当becomesKeyOnlyIfNeeded 方法接收到一个鼠标按下的事件的时候，它返回一个YES。它尝试将鼠标光标下的视图变为第一响应者。当且仅当调用方法 acceptsFirstResponder和needsPanelToBecomeKey返回YES的时候，才能够成功将光标下的视图变为第一响应者。</p>
<h1 id="下一个响应者（Next-Responders）"><a href="#下一个响应者（Next-Responders）" class="headerlink" title="下一个响应者（Next Responders）"></a>下一个响应者（Next Responders）</h1><p>每个响应对象都有一个能力，就是获得它在响应链上的下一个响应者，也就是责任链中将消息往前推的默认操作。 响应链的最主要的机制，就是返回响应者对象的nextResponder方法。图3-1显示了下一个响应者的序列。</p>
<img src="/2017/06/27/chain-of-responsibility-2/responder_chain_2x.png" alt="图3-1 响应者链" title="图3-1 响应者链">
<p>绝大数的响应链上，一个view的下一个响应者一般是它的superview。实际上，一个窗口的所有视图，由它的第一个响应者到它的内容视图链组成。当你用Interface Builder或者手动写代码创建一个窗口或者在已经存在的视图上添加子视图的时候，Application Kit自动将新建的对象添加到响应链中。NSView对象的addSubView:方法自动将接收者设置成新的子视图的superview。当你想要在这些视图之间插入一个不一样的响应者，必须保证正确地修正整个响应链，以适应新的变化。</p>
<h1 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h1><p>响应链将一系列的响应对象串联起来，这些响应对象接收事件或者消息的传递。当一个给定的响应对象不处理一个特定的消息的时候，这个对象会将当前消息传递给它在响应链上的继承者（也就是它的下一个响应者）。这就使得响应对象能够代理其他对象的责任，尤其是更高等级的对象。Application Kit按照以下将要说道的方法自动构建响应链，但是你也可以将一般的对象插入到其中。</p>
<p>一个应用可以包含任何数量的响应链，但是在一个给定的时间，只有一条链是活动的。事件消息和动作消息的响应链是不一样的，下面将详细描述它们的具体操作情况。</p>
<h2 id="事件消息的响应链"><a href="#事件消息的响应链" class="headerlink" title="事件消息的响应链"></a>事件消息的响应链</h2><p>几乎所有的事件消息都使用一个单一窗口的响应链 – 相关用户事件发生的所在窗口。事件消息的默认响应链从NSWindow第一个传递消息的视图开始。一个键盘按键的默认响应链从一个窗口的第一响应者开始；一个鼠标或者触控板的默认响应链从用户事件发生的视图开始。如果在那儿，事件不被处理，事件消息将会沿着视图层次向前传递。第一个响应者一般是窗口中被选择的视图对象，而且它的下一个响应者是包含它的视图（superview），等等直到NSwindow对象为止。如果一个NSWindowController对象管理这个窗口，它就是最后的响应者。你可以在这些NSView对象之间插入其他响应者，甚至是在NSWindow对象上面，也就是响应链的顶部。这些被插入的响应者既接收事件消息，也接收动作消息。如果没有对象处理事件，那么响应链的最后一个响应者会调用方法noResponderFor:,代表按键按下事件的终止。当然，事件处理对象（一般是NSWindow和NSView的子类）可以重写这个方法，从而执行一些想要执行的附加操作。</p>
<h2 id="动作消息的响应链"><a href="#动作消息的响应链" class="headerlink" title="动作消息的响应链"></a>动作消息的响应链</h2><p>对于动作信息，Application Kit构建了一个更加详尽的响应链，基于以下两个因素：</p>
<ul>
<li>当前应用是否基于文件架构，如果不是，那么它是否使用 NSWindowController 对象构建窗口</li>
<li>当前应用是否将key window作为主window展示</li>
</ul>
<p>由于动作需要更加灵活的运行时机制来决定它们的目标，动作消息拥有更加详细的响应链。它们不像事件消息，仅仅限制在一个窗口中。</p>
<p>最简单的情况是，一个活动的没有基于文件的窗口，而且没有相关的面板或者次窗口；换句话说，主窗口也是关键窗口(key window)。这种情况下，响应链如下所示：</p>
<blockquote>
<ol>
<li>主窗口的第一响应者和连续的响应对象与视图层次架构一致</li>
<li>主窗口自己</li>
<li>主窗口的代理（无需继承NSResponder）</li>
<li>应用对象，NSApp</li>
<li>应用对象的代理(无需继承NSResponder)</li>
</ol>
</blockquote>
<p>整条链如图4-1所示</p>
<img src="/2017/06/27/chain-of-responsibility-2/nondoc_2x.png" alt="图4-1 不基于文件应用的动作消息的的响应者链" title="图4-1 不基于文件应用的动作消息的的响应者链">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文说明了责任链模式在iOS框架Cocoa下的应用 – <strong>响应链</strong>。以及，事件消息和动作消息如何在响应链上传递。</p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> iOS开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSAPP读书笔记 第3章 程序的机器级表示 访问信息]]></title>
      <url>/2017/06/20/CSAPP-3-1/</url>
      <content type="html"><![CDATA[<p>本文跟随CSAPP新版书，主要针对x86-64架构。</p>
<h1 id="整数寄存器"><a href="#整数寄存器" class="headerlink" title="整数寄存器"></a>整数寄存器</h1><p>一个x86-64的CPU包含一组16个存储64位值的通用寄存器。这些寄存器用来存储整数数据和指针。图1-1显示了这16个寄存器。</p>
<img src="/2017/06/20/CSAPP-3-1/csapp3_35.JPG" alt="图1-1 整数寄存器" title="图1-1 整数寄存器">
<a id="more"></a>
<p>这16个寄存器的名字都以%r开头，后面跟着一些不同命名规则的名字，是指令集的历史演化造成的。最初的8086有8个16位寄存器，即图1-1中的%ax到%bp。每个寄存器都有特殊的用途，它们的名字就反应了它们的用途，如图1-1中最右边的说明。扩展到IA32架构，即通常说的32位系统，这些寄存器也扩展成为了32位，标号从%eax到%ebp。扩展到现在的x86-64后，原来的8个32位寄存器也扩展到了64位，标号从%rax到%rbp。除此之外，还增加了8个新的寄存器，它们的标号按照新的命名规则：从%r8到%r15.</p>
<p>如图1-1中嵌套的方框表明，指令可以对这个16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的两个字节，32位可以访问最低的4个字节，而64位操作可以访问整个寄存器。</p>
<h1 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h1><p>大多数指令有一个或多个操作数(operand)，指示执行一个操作要使用的源数据值，以及放置结果的目的位置。x86-64支持多种操作数格式，如图1-2所示。</p>
<img src="/2017/06/20/CSAPP-3-1/operand_format.png" alt="图1-2 操作数格式" title="图1-2 操作数格式">
<p>源数据值可以以常数形式给出，或是从，寄存器或者内存读出。结果可以存放在寄存器或内存中。因此，操作数被分为三类。第一种是立即数(immediate)，用来表示常数值，书写方式是’$‘后面跟一个标准C表示的整数。第二种类型是寄存器(register)，它表示某个寄存器的内容，用r<sub>a</sub>表示任意寄存器a，用引用R[r<sub>a</sub>]表示它的值。第三类操作数是内存引用，它会根据计算出来的地址（通常是有效地址）访问某个内存位置。我们用符号M<sub>b</sub>[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。一般省去下标b。如图1-2有多种不同的寻址模式。</p>
<h1 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h1><p>C语言程序在调用函数的时候，用到的最常见的操作就是压栈和弹栈操作，理解和熟悉栈操作有助于帮助我们调试函数调用中的一些错误。关于栈的定义和操作这里不详细赘述。在x86-64中，程序栈存放在内存中的某个区域。如图3-1所示，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址最低的。（这里，栈“顶”在图的底部）栈指针%rsp保存着栈顶元素的地址。</p>
<p>表3-1 入栈和出栈</p>
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">效果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pushq    S</td>
<td style="text-align:center">R[%rsp]  ← R[%rsp]-8; <br> M[R[%rsp]] ← S</td>
<td style="text-align:center">将四字压入栈</td>
</tr>
<tr>
<td style="text-align:center">popq     D</td>
<td style="text-align:center">D ← M[R[%rsp]]; <br> R[%rsp] ← R[%rsp]+8</td>
<td style="text-align:center">将四字弹出栈</td>
</tr>
</tbody>
</table>
<p>pushq的指令的功能是把数据压入到栈上，而popq的指令是弹出数据。这些指令都只有一个操作数–压入的数据源和弹出的数据目的。</p>
<p>将一个四字值压入栈中，首先将栈指针减8，然后将值写到新的栈顶地址。因此，pushq %rbp的行为等价于下面两条指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subq $8, %rsp       将栈指针的值减8</div><div class="line">movq %rbp, (%rsp)   将%rbp的值存到内存中</div></pre></td></tr></table></figure>
<p>如图3-1前两栏给出的是，当%rsp为0x108，%rax为0x123时，执行指令pushq %rax的效果。首先%rsp会减8，得到0x100，然后将0x123存放到内存地址0X100处。</p>
<img src="/2017/06/20/CSAPP-3-1/csapp-stack.png" alt="图3-1 栈操作说明" title="图3-1 栈操作说明">
<p>图3-1的第三栏说明的时在执行完pushq后立即执行指令popq %rdx的效果。先从内存中读出值0x123，再写到寄存器%rdx中，然后，寄存器%rsp的值会回到0x108，值0x123仍然会保持在内存位置0x100中，直到被覆盖。无论如何，%rsp指向的地址总是栈顶。</p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 底层原理 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> 寄存器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发之同一应用设置不同图标和名称]]></title>
      <url>/2017/06/14/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E5%90%8C%E4%B8%80%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E5%9B%BE%E6%A0%87%E5%92%8C%E5%90%8D%E7%A7%B0/</url>
      <content type="html"><![CDATA[<p>经常在开发过程中会遇到同一个APP有很多个版本，比如开发调试的版本，AppStore上的版本等。为了便于区分和调试，我们可以针对这些不同的版本选择不一样的图标和应用名称，效果如下图所示：<br><img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/f_results.jpg" alt="final_result" title="final_result"></p>
<a id="more"></a>
<h2 id="创建不同的APP-ID"><a href="#创建不同的APP-ID" class="headerlink" title="创建不同的APP ID"></a>创建不同的APP ID</h2><p>当你安装APP的时候，设备通过它们的APP ID来判断“你是要安装一个新的APP还是要更新一个旧的APP”。所以第一件要做的事情是，在你的个人中心，为你的开发版本创建一个新的APP ID, 也就是我们通常所说的Bundle ID。比方说，你的正式APP ID是com.mycompany.myapp，那么你的调试版本为com.mycompany.myapp-beta或者com.mycompany.myapp-dev。</p>
<h2 id="为不同的版本创建不同的图标"><a href="#为不同的版本创建不同的图标" class="headerlink" title="为不同的版本创建不同的图标"></a>为不同的版本创建不同的图标</h2><p>为了区分两个版本，需要不同的图标,如下图所示：<br><img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/results.png" alt="结果" title="结果"></p>
<p>为了适配不同的大小，可以将你的图标命名为Icon@1x.png, Icon@2x.png, Icon@3x.png, Icon-beta.png and Icon-beta@2x.png, Icon-beta@3x.png.</p>
<h2 id="使用不同的配置（Build-Configurations）"><a href="#使用不同的配置（Build-Configurations）" class="headerlink" title="使用不同的配置（Build Configurations）"></a>使用不同的配置（Build Configurations）</h2><p>默认的Xcode会为你创建两个版本：Debug 和 Release。由于，公司内部需要有个测试版本，所以我一般加上第三个版本，AppStore版。它们的作用如下:</p>
<blockquote>
<ul>
<li>Debug版：当我自己编写代码，并且直接用Xcode，将App放置到我的设备上进行调试的时候；</li>
<li>Release版：当我们小组开发完一个小的迭代版本，需要在公司内部测试的时候，我们一般是打包以后放到<a href="https://fir.im/" target="_blank" rel="external">fir.im</a>上；</li>
<li>AppStore版：部门内测完成，并解决Bug后，放到AppStore上的版本。</li>
</ul>
</blockquote>
<p>添加新的配置项的步骤如下：</p>
<blockquote>
<ol>
<li><p>方式一：<br>选中<strong>PROJECT</strong>的名称，然后选中<strong>Info</strong>，点击<strong>Configurations</strong>下面的+选择<strong>Duplicate “Debug” Configuration</strong>, 如下图：</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/build_setting_01.png" alt="build_setting_01" title="build_setting_01">
</li>
<li><p>方式二：<br>选中<strong>PROJECT</strong>的名称，然后选中<strong>Editor-&gt;Add Configuration-&gt;Duplicate “Debug” Configuration</strong>，如下图所示：</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/build_setting_02.png" alt="build_setting_02" title="build_setting_02">
</li>
</ol>
</blockquote>
<h2 id="整合所有配置"><a href="#整合所有配置" class="headerlink" title="整合所有配置"></a>整合所有配置</h2><h3 id="User-Defined-Setting"><a href="#User-Defined-Setting" class="headerlink" title="User-Defined Setting"></a>User-Defined Setting</h3><p>在Xcode中使用<strong>User-Defined Setting</strong>可以定义一些Xcode编译使用的宏配置（类似于环境变量），为了实现不同环境下App显示的名称和图标不同，可以在<strong>User-Defined Setting</strong>中定义一些有关应用程序名称和应用图标的配置。</p>
<blockquote>
<ol>
<li>添加User-Defined Setting，如下图：<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/user-defined-01.png" alt="user-defined-01" title="user-defined-01">
注意：需要选中<strong>Target</strong>, 再选中选项<strong>Build Settings</strong>, 才能添加<strong>User-Defined Setting</strong>（户自定义设置）。</li>
<li>添加APP_DISPLAY_NAME(APP显示名称)、APP_ICON_NAME(APP图标名称)和BUNDLE_IDENTIFIER（APP Bundle ID）三个配置选项，效果如下图：<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/user-defined-02.png" alt="user-defined-02" title="user-defined-02">
</li>
</ol>
</blockquote>
<h3 id="Info-plist"><a href="#Info-plist" class="headerlink" title="Info.plist"></a>Info.plist</h3><p>在创建一个新的Xcode工程后，会在Supporting Files文件夹下自动生成一个名为”&lt;工程名&gt;-Info.plist”的文件，这个是对工程做一些运行期配置的文件。在这个配置文件中，可以配置应用的图标、应用的显示名称和应用的Bundle ID。</p>
<blockquote>
<ol>
<li><p>配置应用的图标。<br>使用<strong>${APP_ICON_NAME}@1x.png、${APP_ICON_NAME}@2x.png、${APP_ICON_NAME}@3x.png</strong>替代图标的名称。<br>==注意==：保证项目中有对应名称的图片！</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/info_plist_icon_name.png" alt="info_plist_icon_name" title="info_plist_icon_name">
</li>
<li><p>配置应用的名称<br>设置<strong>Bundle display name</strong>为<strong>${APP_DISPLAY_NAME}</strong>，其中<strong>APP_DISPLAY_NAME</strong>是前面<strong>User-Defined Setting</strong>中设置的应用程序名称的配置项。</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/info_plist_display_name.png" alt="info_plist_display_name" title="info_plist_display_name">
</li>
<li><p>配置Bundle ID<br>设置<strong>Bundle identifier</strong>为<strong>${BUNDLE_IDENTIFIER}</strong>，其中<strong>BUNDLE_IDENTIFIER</strong>是前面<strong>User-Defined Setting</strong>中设置的应用程序<strong>Bundle ID</strong>的配置项。</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/info_plist_bundle_id.png" alt="info_plist_bundle_id" title="info_plist_bundle_id">
</li>
</ol>
</blockquote>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>以上步骤完成了基本的配置过程，接下来将应用以上的配置，完成不同图标和应用名称的App的运行和打包。</p>
<blockquote>
<ol>
<li>点击Xcode项目左上角，停止运行按钮旁边的“项目名称”按钮, 打开<strong>Edit Scheme</strong>, 如下图所示：<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/scheme_1.jpg" alt="scheme_1" title="scheme_1"></li>
<li><p>选择对应的配置，项目就会使用不同的配置，如下图：</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/scheme_2.jpg" alt="scheme_2" title="scheme_2">
</li>
<li><p>最后效果如下：</p>
<img src="/2017/06/14/iOS开发之同一应用设置不同图标和名称/f_results.jpg" alt="final_result" title="final_result">
</li>
</ol>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://nilsou.com/blog/2013/07/29/how-to-have-two-versions-of-the-same-app-on-your-device/" target="_blank" rel="external">How to Have Two Versions of the Same App on Your Device</a></li>
<li><a href="http://limlab.io/swift/2016/02/22/xcode-working-with-multiple-environments.html" target="_blank" rel="external">Xcode tricks. Deal with multiple environments easily</a></li>
<li><a href="http://blog.csdn.net/u011303663/article/details/46503641" target="_blank" rel="external">iOS中-Xcode Debug、Release、Archive、Profile、Analyze的概念和区别</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> iOS开发 </tag>
            
            <tag> 应用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之责任链[上]（Chain of Responsibility）]]></title>
      <url>/2017/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%EF%BC%88Chain-of-Responsibility%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了避免请求的发送者和接收者耦合在一起，让多个对象都有可能处理请求。将这些接收对象连结成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<img src="/2017/06/06/设计模式之责任链（Chain-of-Responsibility）/home.png" alt="ATM" title="ATM">
<a id="more"></a>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>考虑用户图形界面中，最简单的一个例子，帮助工具。使用应用的用户，只要点击界面的任何地方，就可以获得他需要的帮助信息。帮助的具体信息取决于界面被选择的地方，例如：有一个对话窗口的帮助按钮和主窗口的帮助按钮，它们的位置和形状类似，但它们提供的帮助信息完全不一样。如果某部分界面不需要特定的帮助信息，那么应用应该展示更加一般化的帮助信息，例如：应用的版本、开发人员等等。</p>
<p>因此，我们可以根据界面的一般性组织帮助信息。用户界面中存在很多对象，但是，很显然，一个帮助请求只会被其中的一个对象处理。</p>
<p>这里存在一个问题，发出帮助请求的对象（按钮）并不知道提供帮助的对象具体是哪个。责任链模式要做的事情是，使得发出这个帮助请求的对象和实际可能提供帮助的对象尽可能的减少耦合关系。</p>
<p>责任链模式的大致思路是，通过给多个对象提供处理请求的机会，使得发送者和接收者解耦合。这个请求会沿着责任链传递，直到链上的一个对象处理它。这里给出一个简单的用户界面的责任链交互图，如图2-1所示。</p>
<img src="/2017/06/06/设计模式之责任链（Chain-of-Responsibility）/2-1.png" alt="图2-1" title="图2-1">
<p>这个链的第一个对象首先接收到请求，它处理请求，或者把请求推送给下一个候选者；接收到请求的候选者按照相同的逻辑处理请求，以此类推。发出请求的对象并不清楚谁会处理请求——也就是说请求都有一个<strong>被隐藏的接收者</strong>。</p>
<p>现在我们假设，用户点击一个“打印帮助”的按钮，用来获得打印相关帮助。这个按钮包含在一个对话窗口的实例当中，而这个对话窗口知道它自己属于哪个窗口对象（应用的工具栏）。图2-2的交互图说明了帮助请求是如何沿着责任链向前传递的。</p>
<img src="/2017/06/06/设计模式之责任链（Chain-of-Responsibility）/2-2.png" alt="图2-2" title="图2-2">
<p>在这个例子中，既不是“aPrintButton”，也不是“aPrintDialog”处理这个请求；在“anApplication”的地方停止了请求的传递，“anApplication”对象最终处理它或者忽略它。产生请求的对象并没有直接引用能够最终处理请求的对象。</p>
<p>为了将这个请求沿着责任链往前传递，并且保持接收者处于隐藏状态，在这个链上的每个对象都需要使用一个共同的接口，用来处理请求和获取它在链上的<strong>继承者</strong>，以便传递请求。例如，帮助系统可以定义一个“HelpHandler”类，这个类有“HandleHelp”的成员函数。“HelpHandler”可以是候选类的父类,也可以被是一个混入类<strong>（MIXIN Class）</strong>。接着，想要处理请求的类就继承 “HelpHandler”类，具体类图如图2-3所示。</p>
<img src="/2017/06/06/设计模式之责任链（Chain-of-Responsibility）/2-3.png" alt="图2-3" title="图2-3">
<p>按钮、对话框和应用类，用“HelpHandler”的“HandleHelp”操作函数来处理帮助请求。“HelpHandler”的 “HandHelp”操作函数，默认将请求向前传递。子类可以重写这个操作，以便在合适的环境下提供帮助；或者，它们可以采用用默认方式将请求向前传递。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一般遇到下列情况时，使用责任链模式：</p>
<blockquote>
<ul>
<li>不止一个对象能够处理请求，而且并不能够提前确定处理者。要保证处理者是自被动识别的；</li>
<li>你想要把问题交个多个对象处理，而且不用确定接收者;</li>
<li>可以动态的指定处理请求的对象。</li>
</ul>
</blockquote>
<h2 id="责任链结构图"><a href="#责任链结构图" class="headerlink" title="责任链结构图"></a>责任链结构图</h2><img src="/2017/06/06/设计模式之责任链（Chain-of-Responsibility）/4-1.png" alt="图4-1" title="图4-1">
<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><blockquote>
<ul>
<li><p>Handler(HelpHandler)</p>
<ul>
<li>定义处理请求的接口 </li>
<li>[可选]实现继承者传递链</li>
</ul>
</li>
<li><p>ConcreteHandler(PrintButton, PrintDialog)</p>
<ul>
<li>处理请求</li>
<li>获取继承者</li>
<li>如果ConcreteHandler能够处理请求，那么它处理；否则，它向前传递请求</li>
</ul>
</li>
<li><p>Client</p>
<ul>
<li>发起请求，并将请求传递给责任链上的第一个ConcreteHandler</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>责任链模式有以下优点：</p>
<ol>
<li><p><em>降低耦合度</em>。这个模式使得一个发起请求的对象，无需知道具体是哪一个对象处理请求。发起请求的对象只需要知道，它的请求一定会被<strong>合适</strong>地处理。发送者和接收者都不知道彼此的存在，整个责任链中的对象也不需要知道整个责任链的具体结构是怎么样的。</p>
</li>
<li><p><em>增加了分配任务的灵活性</em>。当你要在一些对象之间分发任务的时候，责任链给你提供了较好的灵活性。你可以通过增加处理者或者实时地改变责任链，从而增加或者改变处理请求的对象。你可以将处理请求的方法和子类的方法结合，静态地指定处理者。</p>
</li>
<li><p><em>不需要保证接收者</em>。既然一个请求没有明确的接收者，也就是不必保证请求一定会被处理——也就是说请求也许会在链的尽头丢失，一直没有被处理。一个请求也有可能在责任链没有正确配置的情况下丢失。</p>
</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>责任链模式实现的时候需要考虑的问题：</p>
<ol>
<li><p>实现继承者链。实现继承者链有两种方法：<br>(a) 定义新的链接<br>(b) 用已经存在的链接<br>我们到目前为止所举的例子，都是用定义新链接的方法，但是通常情况下，你可以通过使用已经存在对象的引用来产生一个继承者链接。使用已经存在的链接，帮助现实你所需要的整条链，优点十分明显。它不但节省了定义链接所需的成本，而且同时节省了大量存储空间。但是当使用这种方法不能够很好的反映你的应用需求的时候，你仍然需要定义一些新链接。</p>
</li>
<li><p>链接继承者。如果不存在定义一个链所需要的、已经存在的引用，那么你需要亲自引入它们。这种情况下，处理者（Handler）不仅定义请求的接口，而且通常也维护继承者的产生。这使得处理者有了HandleRequset的一个默认实现，也就是将请求传递给继承者。如果一个“ConcreteHandler”对当前请求不感兴趣，那么它不需要重写向前传递的方法，因为它的默认方法就是把请求向前传递。</p>
</li>
<li><p>请求的表达。表达请求有各种不同的方法。最简单的方法，<em>硬编码</em>。这种方法非常便捷和安全, 但是你只能处理“Handler”类定义的一个固定的请求集合内的请求，可扩展性差。另一种方法，使用一个处理函数，以<em>请求码</em>（例如，整数或者字符串）作为参数。这种方法可以增加新的请求，但是需要发送者和接收者遵循一个统一的编码规范。这种方法灵活性更好，但是它需要使用条件语句分发请求。此外，也没有<em>类型安全</em>的方法传递参数，因此请求需要有打包和拆包的过程。很显然，这种方法不太安全。为了定位参数，我们可以使用一个<em>请求对象</em>封装它。一个请求“Request”类能够表示一个请求，而新的请求可以通过继承的方法定义，子类可以添加不同的参数。处理者必需知道请求的类别（具体是哪个子类）。为了确定请求，Request可以定义一个<em>获取</em>函数，用来返回请求类的标识。此外，接收者也可以通RTTI(运行时类别信息)来识别类，只要实际所使用的语言支持。</p>
</li>
</ol>
<h2 id="已知的应用"><a href="#已知的应用" class="headerlink" title="已知的应用"></a>已知的应用</h2><p>MacApp和ET++中的事件处理，NeXT的APPKit的响应器（Responder）。</p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 计算机 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub&Hexo 搭建博客]]></title>
      <url>/2017/05/12/GitHub&amp;Hexo%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>  初入公司，第一个任务就是自己搭建一个博客。其实之前就一直想试一试自己搭建个博客，但出于懒，一直没有动手。直到，刚入职场，公司老板布置了搭建技术博客的任务，才正式对待这个问题。废话不多说，下面就用Github➕ Hexo的方法搭建一个简单的、属于自己的、可定制的博客。</p>
<img src="/2017/05/12/GitHub&Hexo%20搭建博客/home.png" alt="Hexo + Github" title="Hexo + Github">
<a id="more"></a>
<p>==注意==：本文主要针对<strong>Mac</strong>版本，windows版方法类似。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本文利用Github Pages进行远端部署博客后台，用Node.js的一个命令行工具hexo生成博客所需的静态页面。</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>网上搜索git for mac[windows], 根据你的操作系统安装不同版本的git，建议地址: <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">Git_For_Mac</a></p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Node.js官网<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>下载<strong>最新版</strong>。Mac下可先安装<a href="http://mxcl.github.com/homebrew/" target="_blank" rel="external">Home brew</a>包管理器，然后用命令安装最新版。</p>
<pre><code>brew install node
</code></pre><p>如果能够正常使用命令npm，代表安装成功。</p>
<pre><code>npm --version
</code></pre><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>安装完Node.js后，用Node自带的包管理器安装hexo。</p>
<pre><code>npm install hexo-cli -g
</code></pre><p>能正常使用hexo命令，代表安装成功。</p>
<pre><code>hexo --version
</code></pre><p>至此，环境已经搭建完成。接下来是对环境的补充说明，觉得没有必要的可以掠过这段。但很多人在搭建自己的博客的时候对各个需要搭建的环境并不清晰，我简要地理一下关系。</p>
<blockquote>
<ul>
<li>Git主要是本地生成的静态页面部署到远端（Github）；</li>
<li>Node.js是Javascript的运行平台，本文是hexo生成静态页面的引擎；</li>
<li>Hexo是Node.js的一个命令行工具，能够将Markdown编译为静态页面。</li>
</ul>
</blockquote>
<h2 id="Hexo命令和配置"><a href="#Hexo命令和配置" class="headerlink" title="Hexo命令和配置"></a>Hexo命令和配置</h2><h3 id="Hexo-几个常见的命令"><a href="#Hexo-几个常见的命令" class="headerlink" title="Hexo 几个常见的命令"></a>Hexo 几个常见的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成一个hexo工程，文件夹[blogname]</span></div><div class="line">hexo init [blogname]</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成一篇博文，可以路径[blogname]/source/_posts下面找到[passagename].md的文件</span></div><div class="line">hexo new [passagename]</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 生成静态页面</span></div><div class="line">hexo generate[g]</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 将本地代码部署到远端（这里指Github），需要在配置以后才能进行</span></div><div class="line">hexo deploy[d]</div></pre></td></tr></table></figure>
<h3 id="Hexo-配置说明"><a href="#Hexo-配置说明" class="headerlink" title="Hexo 配置说明"></a>Hexo 配置说明</h3><p>在项目的主目录下，可以找到_config.xml，博客主要配置信息。重点说明以下参数：</p>
<blockquote>
<ul>
<li>博客的主要信息：标题、副标题、描述、作者、语言和时区</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: Geek</div><div class="line">subtitle:</div><div class="line">description:</div><div class="line">author: Huanjian Jiang</div><div class="line">language:</div><div class="line">timezone:</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>git配置信息：远程类型、仓库地址、分支和提交信息</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git</div><div class="line">    repo: git@github.com:zhuwo/zhuwo.github.io.git</div><div class="line">    branch: master</div><div class="line">    message: Final try</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>主题</strong></li>
</ul>
<ol>
<li>网上查找Hexo的主题，将主题模版放到路径[blogname]/themes，设置参数theme: master[主题文件夹名]</li>
<li>本人推荐的最流行的Hexo的主题next(可调整性强、内容丰富)，详情见它的主页：<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">http://theme-next.iissnan.com/</a></li>
</ol>
<ul>
<li><strong>图片</strong></li>
</ul>
<p>添加图片的方法可以参考Hexo的官方文档：<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/asset-folders.html</a></p>
</blockquote>
<h4 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h4><blockquote>
<ol>
<li>hexo init 生成博客</li>
<li>修改配置文件_config.xml</li>
<li>hexo deploy 部署到Github</li>
</ol>
</blockquote>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><blockquote>
<ol>
<li>每次添加markdown文件以后都要重新生成静态页面 </li>
<li>每次本地操作以后都要重新部署到github</li>
<li>配置项目的”:”后必须跟一个空格，比方说theme:[空格][模版名]</li>
</ol>
</blockquote>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>作为一个程序员，github的使用是必须的，这里并不累赘复述如何注册github账号，如何在github创建仓库等等，只说明创建博客时的注意点。</p>
<blockquote>
<ul>
<li>新建一个仓库后，仓库名必须与GitHub帐户一致，比方说的我的github地址为<a href="https://github.com/zhuwo" target="_blank" rel="external">https://github.com/zhuwo</a>, 那么仓库名必须为zhuwo.github.io。这样，最后你的博客地址也就是<a href="https://zhuwo.github.io。" target="_blank" rel="external">https://zhuwo.github.io。</a></li>
<li>使用Git部署之前，需要安装 hexo-deployer-git，命令如下：</li>
</ul>
</blockquote>
<pre><code>$ npm install hexo-deployer-git --save
</code></pre><blockquote>
<ul>
<li>本地部署到github以后，再在仓库的设置页面，将分支改为master（仓库没有数据的时候不能选择分支，也就没有github page）</li>
</ul>
</blockquote>
<p>最后，在仓库的设置页面可以看到github page的地址，也就是你的博客地址。</p>
<hr>
<p>欢迎大家访问我的博客Geek: <a href="https://zhuwo.github.io" target="_blank" rel="external">https://zhuwo.github.io</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5308028&auto=1&height=66"></iframe>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>网易云音乐生成外链，代码直接拷贝Markdown文件中</li>
</ol>
<h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><ol>
<li><a href="https://notes.wanghao.work/" target="_blank" rel="external">https://notes.wanghao.work/</a></li>
<li><a href="http://www.dingxuewen.com/" target="_blank" rel="external">http://www.dingxuewen.com/</a></li>
<li><a href="https://unindented.org" target="_blank" rel="external">https://unindented.org</a></li>
</ol>
<p>​<br>​    </p>
]]></content>
      
        <categories>
            
            <category> Technology </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 博客 </tag>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/05/10/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
